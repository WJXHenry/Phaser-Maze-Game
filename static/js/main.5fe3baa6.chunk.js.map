{"version":3,"sources":["common/colours.js","Phaser/Scenes/Movement.js","Phaser/Game/gameSettings.js","Phaser/Game/gestures.js","Phaser/Scenes/MainMenu.js","Phaser/Scenes/Settings.js","Phaser/Utils/graph.js","Phaser/Game/gameMaze.js","Phaser/Utils/maze.js","Phaser/Scenes/StartGame.js","Phaser/Scenes/EndScreen.js","Phaser/Game.js","App.js","serviceWorker.js","index.js","common/shuffle.js"],"names":["module","exports","BLACK","BLACK_0x","GOLD","GOLD_0x","GRAY","GRAY_0x","WHITE","WHITE_0x","Movement","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","sprite","direction","y","x","load","setBaseURL","image","_this","cameras","main","setBackgroundColor","counter","keys","input","keyboard","addKeys","up","down","left","right","addKey","on","scene","start","player","add","console","log","isDown","updateMovement","Phaser","Scene","getDimensions","game","screenLength","config","width","screenSpaceUnit","screenCenter","textSize1","textSize2","textSize3","textSize4","GESTURES","SWIPE_RIGHT","SWIPE_LEFT","SWIPE_UP","SWIPE_DOWN","SINGLE_TAP","DOUBLE_TAP","TP_SWIPE_RIGHT","NONE_DETECTED","gestureDetection","inputManager","callback","options","arguments","length","undefined","pointer","swipeThreshold","deltaTime","upTime","downTime","velX","upX","downX","velY","upY","downY","speedX","Math","abs","speedY","detectGesture","MainMenu","data","settings","objectSpread","maxGridSize","minGridSize","gridSize","maxSideLength","minSideLength","sideLength","gameMode","handleGesture","bind","arrowUp","arrowDown","select","gameDimensions","choice","doubleTapTimer","doubleTapCooldown","text","fontFamily","fill","fontSize","setOrigin","startGame","exit","gesture","updateChoice","Date","getTime","Input","Keyboard","JustDown","newChoice","setFill","Settings","arrowLeft","arrowRight","gameModes","concat","menuReturn","updateSelection","updateGridSize","updateSideLength","updateGameMode","newGridSize","setText","newSideLength","newGameMode","Graph","vertices","Set","edges","alist","forEach","v","addVertex","e","addEdge","_this2","key","vertex","Number","isInteger","push","isVertex","Error","has","Array","from","g","walk","i","isEdge","path","size","isWalk","GameMaze","graphics","colour","fillStyle","maze","getVertices","pos","split","vertX","vertY","rectX","rectY","lengthX","lengthY","fillRect","position","Maze","_createGrid","_createMaze","floor","grid","j","completed","paths","shuffle","coords","map","parseInt","StartGame","directions","UP","DOWN","LEFT","RIGHT","playerPos","endPoint","drawMaze","fillGrid","timer","prevPos","results","time","EndScreen","SOLO","TWO_PLAYER","RACE","CHASE","ESCAPE","continue","drawScreen","Game","dimension","_getDimensions","type","AUTO","parent","pixelArt","height","physics","default","arcade","gravity","window","innerWidth","innerHeight","react_default","a","createElement","id","React","Component","App","className","Game_Game","Boolean","location","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","array","temporaryValue","randomIndex","currentIndex","random"],"mappings":"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","file":"static/js/main.5fe3baa6.chunk.js","sourcesContent":["const BLACK = '#000000';\nconst GOLD = '#f9a602';\nconst WHITE = '#ffffff';\nconst GRAY = '#cccccc';\n\n// '0x' notation\nconst BLACK_0x = '0x000000';\nconst GOLD_0x = '0xf9a602';\nconst WHITE_0x = '0xffffff';\nconst GRAY_0x = '0xcccccc';\n\nmodule.exports = {\n  BLACK,\n  BLACK_0x,\n  GOLD,\n  GOLD_0x,\n  GRAY,\n  GRAY_0x,\n  WHITE,\n  WHITE_0x\n};\n","import Phaser from 'phaser';\n\nexport default class Movement extends Phaser.Scene {\n  constructor() {\n    super('Movement');\n  }\n\n  updateMovement(sprite, direction) {\n    if (direction === 'up') {\n      sprite.y -= 2;\n      if (sprite.y < 0) {\n        sprite.y = 0;\n      }\n    } else if (direction === 'down') {\n      sprite.y += 2;\n      if (sprite.y > 600) {\n        sprite.y = 600;\n      }\n    } else if (direction === 'left') {\n      sprite.x -= 2;\n      if (sprite.x < 0) {\n        sprite.x = 0;\n      }\n    } else if (direction === 'right') {\n      sprite.x += 2;\n      if (sprite.x > 800) {\n        sprite.x = 800;\n      }\n    }\n  }\n\n  // redrawRect(prevPos, newPos, drawGraphics, redrawGraphics) {\n  //   let prevRect = new Phaser.Geom.Rectangle(prevPos.x, prevPos.y, 20, 20);\n  //   let newRect = new Phaser.Geom.Rectangle(newPos.x, newPos.y, 20, 20);\n  //   redrawGraphics.fillRectShape(prevRect);\n  //   drawGraphics.fillRectShape(newRect);\n  // }\n\n  preload() {\n    this.load.setBaseURL(\n      'https://raw.githubusercontent.com/wjxhenry/website/master'\n    );\n    // Load assets\n    this.load.image('player', 'assets/test/red.png');\n  }\n\n  create() {\n    // this.cameras.main.setBackgroundColor('rgba(125,0,255,1)'); // Set rgb background colour\n    // this.cameras.main.setBackgroundColor('#800080');\n    // this.cameras.main.setBackgroundColor('#ffffff');\n    this.cameras.main.setBackgroundColor('#000000');\n    this.counter = 0;\n    this.keys = this.input.keyboard.addKeys({\n      up: 'W',\n      down: 'S',\n      left: 'A',\n      right: 'D'\n    });\n    // this.playerPos = { x: 0, y: 0 };\n    var keyObj = this.input.keyboard.addKey('ESC');\n    keyObj.on('down', () => {\n      this.scene.start('MainMenu');\n      //   Fix the issue where there are multiple logs??\n    });\n    this.player = this.add.sprite(0, 0, 'player');\n    console.log('Start Movement');\n    // keyObj.on('up', event => {\n    //   console.log('W key up');\n    // });\n  }\n\n  update() {\n    this.counter++;\n    if (this.counter % 1 === 0) {\n      // Clock updates every 60 (milli?)seconds\n      // console.log(\"Tick\")\n      this.counter = 0; // Reset counter (just in case of overflow?)\n      if (this.keys.up.isDown) {\n        console.log('Up');\n        this.updateMovement(this.player, 'up');\n      }\n      if (this.keys.down.isDown) {\n        console.log('Down');\n        this.updateMovement(this.player, 'down');\n      }\n      if (this.keys.left.isDown) {\n        console.log('Left');\n        this.updateMovement(this.player, 'left');\n      }\n      if (this.keys.right.isDown) {\n        console.log('Right');\n        this.updateMovement(this.player, 'right');\n      }\n      // console.log(this.playerPos);\n    }\n    // console.log(\"TestScene: update\")\n  }\n}\n","/**\n * Returns custom dimensions for the game instance\n * @param {Phaser.Game} game The Phaser Game object\n * @returns {Object} The custom dimensions object\n */\nexport function getDimensions(game) {\n  const screenLength = game.config.width;\n  return {\n    screenLength,\n    screenSpaceUnit: screenLength / 20,\n    screenCenter: screenLength / 2,\n    textSize1: screenLength / 10,\n    textSize2: screenLength / 15,\n    textSize3: screenLength / 18,\n    textSize4: screenLength / 22\n  };\n}\n\n/**\n * The initial settings for the game (game configs)\n * @returns {Object} The initial/default settings for the game configurations\n */\nexport function initSettings() {\n  return {\n    maxGridSize: 35,\n    minGridSize: 10,\n    gridSize: 20,\n    maxSideLength: 15,\n    minSideLength: 10,\n    sideLength: 10,\n    gameMode: 0\n  };\n}\n","/**\n * @enum {Gesture}\n */\nexport const GESTURES = {\n  SWIPE_RIGHT: 0,\n  SWIPE_LEFT: 1,\n  SWIPE_UP: 2,\n  SWIPE_DOWN: 3,\n  SINGLE_TAP: 4,\n  DOUBLE_TAP: 5, // Not sure if this can be implemented here (maybe separately)\n  TP_SWIPE_RIGHT: 6, // TP = Two Pointer... (WIP)\n  NONE_DETECTED: 7\n};\n\n/**\n * Register input manager for gesture detection\n * @param {Phaser.Input.InputPlugin} inputManager The input manager that handles all input related events\n * @callback callback The callback function that handles the detected gesture\n *  @param {Gesture} gesture The detected gesture\n * @param {Object} options\n * @param {Number} options.swipeThreshold The swipe threshold for the detection\n */\nexport function gestureDetection(inputManager, callback, options = {}) {\n  inputManager.on('pointerup', pointer => {\n    callback(detectGesture(pointer, options));\n  });\n}\n\nfunction detectGesture(pointer, options) {\n  let swipeThreshold = options.swipeThreshold || 100;\n  let deltaTime = (pointer.upTime - pointer.downTime) / 1000;\n  let velX = (pointer.upX - pointer.downX) / deltaTime;\n  let velY = (pointer.upY - pointer.downY) / deltaTime;\n  let speedX = Math.abs(velX);\n  let speedY = Math.abs(velY);\n  if (speedX > speedY && speedX > swipeThreshold) {\n    if (velX < 0) {\n      return GESTURES.SWIPE_LEFT;\n    } else {\n      return GESTURES.SWIPE_RIGHT;\n    }\n  } else if (speedY > speedX && speedY > swipeThreshold) {\n    if (velY < 0) {\n      return GESTURES.SWIPE_UP;\n    } else {\n      return GESTURES.SWIPE_DOWN;\n    }\n  }\n  return GESTURES.SINGLE_TAP;\n}\n\n// Swipe gestures without using time (speed/velocity)\n// eslint-disable-next-line\nfunction detectGestureNoTime(pointer, options) {\n  let swipeThreshold = options.swipeThreshold || 50;\n  let displacementX = pointer.upX - pointer.downX;\n  let displacementY = pointer.upY - pointer.downY;\n  let distanceX = Math.abs(displacementX);\n  let distanceY = Math.abs(displacementY);\n  if (distanceX > distanceY && distanceX > swipeThreshold) {\n    if (displacementX < 0) {\n      return GESTURES.SWIPE_LEFT;\n    } else {\n      return GESTURES.SWIPE_RIGHT;\n    }\n  } else if (distanceY > distanceX && distanceY > swipeThreshold) {\n    if (displacementY < 0) {\n      return GESTURES.SWIPE_UP;\n    } else {\n      return GESTURES.SWIPE_DOWN;\n    }\n  }\n  return GESTURES.SINGLE_TAP;\n}\n","import Phaser from 'phaser';\nimport { initSettings, getDimensions } from '../Game/gameSettings';\nimport { BLACK, GOLD, WHITE } from '../../common/colours';\nimport { GESTURES, gestureDetection } from '../Game/gestures';\n\nexport default class MainMenu extends Phaser.Scene {\n  constructor() {\n    super('MainMenu');\n  }\n\n  init(data) {\n    this.settings = { ...initSettings(), ...data };\n    this.handleGesture = this.handleGesture.bind(this);\n  }\n\n  preload() {\n    this.load.setBaseURL(\n      'https://raw.githubusercontent.com/wjxhenry/website/master'\n    );\n    // Load assets...\n  }\n\n  create() {\n    this.cameras.main.setBackgroundColor(WHITE);\n    this.keys = this.input.keyboard.addKeys({\n      up: 'W',\n      arrowUp: 'up',\n      down: 'S',\n      arrowDown: 'down',\n      select: 'Enter'\n    });\n    gestureDetection(this.input, this.handleGesture);\n\n    this.gameDimensions = getDimensions(this.game);\n\n    this.choice = 0;\n\n    this.doubleTapTimer = 0;\n    this.doubleTapCooldown = 200; // 200 milliseconds between each tap\n\n    let title = this.add.text(\n      this.gameDimensions.screenCenter,\n      this.gameDimensions.screenSpaceUnit * 4,\n      'Yet Another Maze',\n      {\n        fontFamily: 'Ubuntu',\n        fill: BLACK,\n        fontSize: this.gameDimensions.textSize2\n      }\n    );\n    title.setOrigin(0.5, 0.5);\n    let startGame = this.add.text(\n      this.gameDimensions.screenCenter,\n      this.gameDimensions.screenSpaceUnit * 8,\n      'Start Game',\n      {\n        fontFamily: 'Ubuntu',\n        fill: GOLD,\n        fontSize: this.gameDimensions.textSize3\n      }\n    );\n    startGame.setOrigin(0.5, 0.5);\n    let settings = this.add.text(\n      this.gameDimensions.screenCenter,\n      this.gameDimensions.screenSpaceUnit * 12,\n      'Settings',\n      {\n        fontFamily: 'Ubuntu',\n        fill: BLACK,\n        fontSize: this.gameDimensions.textSize3\n      }\n    );\n    settings.setOrigin(0.5, 0.5);\n    let exit = this.add.text(\n      this.gameDimensions.screenCenter,\n      this.gameDimensions.screenSpaceUnit * 16,\n      'Exit',\n      {\n        fontFamily: 'Ubuntu',\n        fill: BLACK,\n        fontSize: this.gameDimensions.textSize3\n      }\n    );\n    exit.setOrigin(0.5, 0.5);\n\n    this.options = [\n      { text: startGame, scene: 'StartGame' },\n      { text: settings, scene: 'Settings' },\n      { text: exit, scene: 'Movement' }\n    ];\n  }\n\n  handleGesture(gesture) {\n    if (gesture === GESTURES.SWIPE_UP) {\n      this.updateChoice(-1);\n    } else if (gesture === GESTURES.SWIPE_DOWN) {\n      this.updateChoice(1);\n    } else if (gesture === GESTURES.SINGLE_TAP) {\n      if (new Date().getTime() - this.doubleTapTimer < this.doubleTapCooldown) {\n        this.scene.start(this.options[this.choice].scene, this.settings);\n      }\n      this.doubleTapTimer = new Date().getTime();\n    }\n  }\n\n  update() {\n    if (\n      Phaser.Input.Keyboard.JustDown(this.keys.up) ||\n      Phaser.Input.Keyboard.JustDown(this.keys.arrowUp)\n    ) {\n      this.updateChoice(-1);\n    }\n    if (\n      Phaser.Input.Keyboard.JustDown(this.keys.down) ||\n      Phaser.Input.Keyboard.JustDown(this.keys.arrowDown)\n    ) {\n      this.updateChoice(1);\n    }\n    if (Phaser.Input.Keyboard.JustDown(this.keys.select)) {\n      this.scene.start(this.options[this.choice].scene, this.settings);\n    }\n  }\n\n  updateChoice(direction) {\n    let newChoice = this.choice + direction;\n    if (newChoice > -1 && newChoice < this.options.length) {\n      this.options[this.choice].text.setFill(BLACK);\n      this.options[newChoice].text.setFill(GOLD);\n      this.choice = newChoice;\n    }\n  }\n}\n","import Phaser from 'phaser';\nimport { getDimensions } from '../Game/gameSettings';\nimport { BLACK, GOLD, WHITE } from '../../common/colours';\nimport { GESTURES, gestureDetection } from '../Game/gestures';\n\nexport default class Settings extends Phaser.Scene {\n  constructor() {\n    super('Settings');\n  }\n\n  init(data) {\n    this.settings = data;\n    this.handleGesture = this.handleGesture.bind(this);\n  }\n\n  preload() {\n    this.load.setBaseURL(\n      'https://raw.githubusercontent.com/wjxhenry/website/master'\n    );\n    // Load assets...\n  }\n\n  create() {\n    this.cameras.main.setBackgroundColor(WHITE);\n    this.keys = this.input.keyboard.addKeys({\n      up: 'W',\n      arrowUp: 'up',\n      down: 'S',\n      arrowDown: 'down',\n      left: 'A',\n      arrowLeft: 'left',\n      right: 'D',\n      arrowRight: 'right',\n      select: 'Enter'\n    });\n    gestureDetection(this.input, this.handleGesture);\n\n    this.gameDimensions = getDimensions(this.game);\n\n    this.gameModes = ['Solo', 'Two Player', 'Race', 'Chase', 'Escape'];\n\n    this.choice = 0;\n\n    this.doubleTapTimer = 0;\n    this.doubleTapCooldown = 200; // 200 milliseconds between each tap\n\n    let title = this.add.text(\n      this.gameDimensions.screenCenter,\n      this.gameDimensions.screenSpaceUnit * 4,\n      'Settings',\n      {\n        fontFamily: 'Ubuntu',\n        fill: BLACK,\n        fontSize: this.gameDimensions.textSize1\n      }\n    );\n    title.setOrigin(0.5, 0.5);\n    let gridSize = this.add.text(\n      this.gameDimensions.screenCenter,\n      this.gameDimensions.screenSpaceUnit * 8,\n      `Grid size: ${this.settings.gridSize}`,\n      {\n        fontFamily: 'Ubuntu',\n        fill: GOLD,\n        fontSize: this.gameDimensions.textSize3\n      }\n    );\n    gridSize.setOrigin(0.5, 0.5);\n    let sideLength = this.add.text(\n      this.gameDimensions.screenCenter,\n      this.gameDimensions.screenSpaceUnit * 11,\n      `Side length: ${this.settings.sideLength}`,\n      {\n        fontFamily: 'Ubuntu',\n        fill: BLACK,\n        fontSize: this.gameDimensions.textSize3\n      }\n    );\n    sideLength.setOrigin(0.5, 0.5);\n    let gameMode = this.add.text(\n      this.gameDimensions.screenCenter,\n      this.gameDimensions.screenSpaceUnit * 14,\n      this.gameModes[this.settings.gameMode],\n      {\n        fontFamily: 'Ubuntu',\n        fill: BLACK,\n        fontSize: this.gameDimensions.textSize3\n      }\n    );\n    gameMode.setOrigin(0.5, 0.5);\n    let menuReturn = this.add.text(\n      this.gameDimensions.screenCenter,\n      this.gameDimensions.screenSpaceUnit * 17,\n      'Return',\n      {\n        fontFamily: 'Ubuntu',\n        fill: BLACK,\n        fontSize: this.gameDimensions.textSize3\n      }\n    );\n    menuReturn.setOrigin(0.5, 0.5);\n\n    this.options = [gridSize, sideLength, gameMode, menuReturn];\n  }\n\n  handleGesture(gesture) {\n    if (gesture === GESTURES.SWIPE_UP) {\n      this.updateChoice(-1);\n    } else if (gesture === GESTURES.SWIPE_DOWN) {\n      this.updateChoice(1);\n    } else if (gesture === GESTURES.SWIPE_RIGHT) {\n      this.updateSelection(1);\n    } else if (gesture === GESTURES.SWIPE_LEFT) {\n      this.updateSelection(-1);\n    } else if (gesture === GESTURES.SINGLE_TAP) {\n      if (new Date().getTime() - this.doubleTapTimer < this.doubleTapCooldown) {\n        if (this.choice === 3) {\n          this.scene.start('MainMenu', this.settings);\n        }\n      }\n      this.doubleTapTimer = new Date().getTime();\n    }\n  }\n\n  update() {\n    if (\n      Phaser.Input.Keyboard.JustDown(this.keys.up) ||\n      Phaser.Input.Keyboard.JustDown(this.keys.arrowUp)\n    ) {\n      this.updateChoice(-1);\n    }\n    if (\n      Phaser.Input.Keyboard.JustDown(this.keys.down) ||\n      Phaser.Input.Keyboard.JustDown(this.keys.arrowDown)\n    ) {\n      this.updateChoice(1);\n    }\n    if (\n      Phaser.Input.Keyboard.JustDown(this.keys.right) ||\n      Phaser.Input.Keyboard.JustDown(this.keys.arrowRight)\n    ) {\n      this.updateSelection(1);\n    }\n    if (\n      Phaser.Input.Keyboard.JustDown(this.keys.left) ||\n      Phaser.Input.Keyboard.JustDown(this.keys.arrowLeft)\n    ) {\n      this.updateSelection(-1);\n    }\n    if (Phaser.Input.Keyboard.JustDown(this.keys.select)) {\n      if (this.choice === 3) {\n        this.scene.start('MainMenu', this.settings);\n      }\n    }\n  }\n\n  updateChoice(direction) {\n    let newChoice = this.choice + direction;\n    if (newChoice > -1 && newChoice < this.options.length) {\n      this.options[this.choice].setFill(BLACK);\n      this.options[newChoice].setFill(GOLD);\n      this.choice = newChoice;\n    }\n  }\n\n  updateSelection(direction) {\n    if (this.choice === 0) {\n      this.updateGridSize(direction);\n    } else if (this.choice === 1) {\n      this.updateSideLength(direction);\n    } else if (this.choice === 2) {\n      this.updateGameMode(direction);\n    }\n  }\n\n  updateGridSize(direction) {\n    let newGridSize = this.settings.gridSize + direction;\n    if (\n      newGridSize > this.settings.minGridSize - 1 &&\n      newGridSize < this.settings.maxGridSize + 1\n    ) {\n      this.options[0].setText(`Grid size: ${newGridSize}`);\n      this.settings.gridSize = newGridSize;\n    }\n  }\n\n  updateSideLength(direction) {\n    let newSideLength = this.settings.sideLength + direction;\n    if (\n      newSideLength > this.settings.minSideLength - 1 &&\n      newSideLength < this.settings.maxSideLength + 1\n    ) {\n      this.options[1].setText(`Side length: ${newSideLength}`);\n      this.settings.sideLength = newSideLength;\n    }\n  }\n\n  updateGameMode(direction) {\n    let newGameMode = this.settings.gameMode + direction;\n    if (newGameMode > -1 && newGameMode < this.gameModes.length) {\n      this.options[2].setText(this.gameModes[newGameMode]);\n      this.settings.gameMode = newGameMode;\n    }\n  }\n}\n","/**\n * Directed Graph Class\n *\n * This graph class is a container that holds a set\n * of vertices and a list of directed edges.\n * Edges are modelled as tuples (u,v) of vertices.\n *\n * Uses an adjacency list representation. Loops\n * and parallel copies of edges can be stored.\n */\n\nexport default class Graph {\n  constructor(vertices = new Set(), edges = []) {\n    this.alist = {};\n\n    vertices.forEach(v => {\n      this.addVertex(v);\n    });\n    edges.forEach(e => {\n      this.addEdge(e);\n    });\n  }\n\n  getVertices() {\n    return new Set(Object.keys(this.alist));\n  }\n\n  getEdges() {\n    let edges = [];\n    Object.keys(this.alist).forEach(key => {\n      this.alist[key].forEach(vertex => {\n        if (Number.isInteger(vertex)) {\n          edges.push([Number(key), vertex]);\n        } else {\n          edges.push([key, vertex]);\n        }\n      });\n    });\n    return edges;\n  }\n\n  addVertex(v) {\n    if (!(v in this.alist)) {\n      this.alist[v] = new Set();\n    }\n  }\n\n  addEdge(e) {\n    if (!this.isVertex(e[0]) || !this.isVertex(e[1])) {\n      throw new Error('An endpoint is not in graph');\n    }\n    this.alist[e[0]].add(e[1]);\n  }\n\n  isVertex(v) {\n    return v in this.alist;\n  }\n\n  isEdge(e) {\n    if (!(e[0] in this.alist)) {\n      return false;\n    }\n    return this.alist[e[0]].has(e[1]);\n  }\n\n  neighbours(v) {\n    if (!this.isVertex(v)) {\n      throw new Error('Vertex not in graph');\n    }\n    return Array.from(this.alist[v]);\n  }\n\n  static isWalk(g, walk) {\n    if (walk.length === 0)\n      // Should have at least one vertex\n      return false;\n\n    if (walk.length === 1) return g.isVertex(walk[0]);\n\n    for (let i = 0; i < walk.length - 1; i++) {\n      if (!g.isEdge([walk[i], walk[i + 1]])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  static isPath(g, path) {\n    if (new Set(path).size < path.length) return false;\n\n    return this.isWalk(g, path);\n  }\n}\n","import Maze from '../Utils/maze';\nimport { getDimensions } from './gameSettings';\nimport { WHITE_0x } from '../../common/colours';\n\nexport default class GameMaze extends Maze {\n  /**\n   * Constructor\n   * @param {Phaser.Game} game The Phaser game object\n   * @param {Phaser.GameObjects.Graphics} graphics The Phaser graphics object\n   * @param {Number} size The size of the maze (size x size grid)\n   * @param {Number} colour The hexadecimal colour to fill in the maze (colour of the paths)\n   */\n  constructor(game, graphics, size, colour = WHITE_0x) {\n    super(size);\n    this.game = game;\n    this.graphics = graphics;\n    this.gameDimensions = getDimensions(this.game);\n    this.sideLength = (this.gameDimensions.screenLength - 2) / size;\n    this.colour = colour;\n  }\n\n  /**\n   * Draws the maze\n   */\n  drawMaze() {\n    this.graphics.fillStyle(this.colour);\n    this.maze.getVertices().forEach(vertex => {\n      let pos = vertex.split(',');\n      // Vertex\n      let vertX = Number(pos[0]);\n      let vertY = Number(pos[1]);\n      // Grid unit\n      let rectX = vertX * this.sideLength + 1;\n      let rectY = vertY * this.sideLength + 1;\n      let lengthX = this.sideLength - 2;\n      let lengthY = this.sideLength - 2;\n      // Update the grid unit dimensions\n      if (this.maze.isEdge([vertex, `${vertX - 1},${vertY}`])) {\n        rectX -= 1;\n        lengthX += 1;\n      }\n      if (this.maze.isEdge([vertex, `${vertX + 1},${vertY}`])) {\n        lengthX += 1;\n      }\n      if (this.maze.isEdge([vertex, `${vertX},${vertY - 1}`])) {\n        rectY -= 1;\n        lengthY += 1;\n      }\n      if (this.maze.isEdge([vertex, `${vertX},${vertY + 1}`])) {\n        lengthY += 1;\n      }\n      // Draw the grid unit\n      this.graphics.fillRect(rectX, rectY, lengthX, lengthY);\n    });\n  }\n\n  /**\n   * Fill the grid with colour at the specified position\n   * @param {Object} position\n   * @param {Number} position.x The x coordinate of the vertex to fill\n   * @param {Number} position.y The y coordinate of the vertex to fill\n   * @param {Number} colour Hexadecimal colour of the grid\n   */\n  fillGrid(position, colour) {\n    this.graphics.fillStyle(colour);\n    this.graphics.fillRect(\n      position.x * this.sideLength + 1,\n      position.y * this.sideLength + 1,\n      this.sideLength - 2,\n      this.sideLength - 2\n    );\n  }\n}\n","import Graph from './graph';\nimport { shuffle } from '../../common/shuffle';\n\nexport default class Maze {\n  constructor(size = 0) {\n    this.maze = this._createGrid(size);\n    this._createMaze(`${Math.floor(size / 2)},${Math.floor(size / 2)}`);\n  }\n\n  getVertices() {\n    return this.maze.getVertices();\n  }\n\n  isEdge(e) {\n    return this.maze.isEdge(e);\n  }\n\n  _createGrid(size) {\n    let grid = new Graph();\n    for (let i = 0; i < size; i++) {\n      for (let j = 0; j < size; j++) {\n        grid.addVertex(`${i},${j}`);\n      }\n    }\n    return grid;\n  }\n\n  _createMaze(vertex, completed = null, vertices = null) {\n    if (vertices == null) {\n      vertices = this.getVertices();\n    }\n    if (completed == null) {\n      completed = new Set(vertex);\n    }\n\n    let paths = shuffle(['up', 'down', 'left', 'right']);\n\n    let coords = vertex.split(',').map(position => {\n      return parseInt(position);\n    });\n\n    let up = `${coords[0]},${coords[1] - 1}`;\n    let down = `${coords[0]},${coords[1] + 1}`;\n    let left = `${coords[0] - 1},${coords[1]}`;\n    let right = `${coords[0] + 1},${coords[1]}`;\n\n    paths.forEach(direction => {\n      if (direction === 'up') {\n        if (vertices.has(up) && !completed.has(up)) {\n          this.maze.addEdge([vertex, up]);\n          this.maze.addEdge([up, vertex]);\n          completed.add(up);\n          this._createMaze(up, completed, vertices);\n        }\n      } else if (direction === 'down') {\n        if (vertices.has(down) && !completed.has(down)) {\n          this.maze.addEdge([vertex, down]);\n          this.maze.addEdge([down, vertex]);\n          completed.add(down);\n          this._createMaze(down, completed, vertices);\n        }\n      } else if (direction === 'left') {\n        if (vertices.has(left) && !completed.has(left)) {\n          this.maze.addEdge([vertex, left]);\n          this.maze.addEdge([left, vertex]);\n          completed.add(left);\n          this._createMaze(left, completed, vertices);\n        }\n      } else if (direction === 'right') {\n        if (vertices.has(right) && !completed.has(right)) {\n          this.maze.addEdge([vertex, right]);\n          this.maze.addEdge([right, vertex]);\n          completed.add(right);\n          this._createMaze(right, completed, vertices);\n        }\n      }\n    });\n  }\n}\n","import Phaser from 'phaser';\nimport { WHITE_0x, BLACK_0x, GOLD_0x, GRAY_0x } from '../../common/colours';\nimport GameMaze from '../Game/gameMaze';\nimport { GESTURES, gestureDetection } from '../Game/gestures';\n\nexport default class StartGame extends Phaser.Scene {\n  constructor() {\n    super('StartGame');\n  }\n\n  init(data) {\n    this.settings = data;\n    this.directions = {\n      UP: 'up',\n      DOWN: 'down',\n      LEFT: 'left',\n      RIGHT: 'right'\n    };\n    this.handleGesture = this.handleGesture.bind(this);\n  }\n\n  preload() {\n    // Load assets...\n  }\n\n  create() {\n    this.cameras.main.setBackgroundColor(BLACK_0x);\n    this.keys = this.input.keyboard.addKeys({\n      up: 'W',\n      arrowUp: 'up',\n      down: 'S',\n      arrowDown: 'down',\n      left: 'A',\n      arrowLeft: 'left',\n      right: 'D',\n      arrowRight: 'right',\n      exit: 'Esc'\n    });\n    gestureDetection(this.input, this.handleGesture);\n\n    // TODO: Change this scene to 'SOLO' game mode\n    // TODO: method to initialise different game modes -> or implement the different game modes as different scenes!\n    // TODO: side length is not needed -> just calculate from grid size and window length\n\n    // The border for the maze is 1\n    this.graphics = this.add.graphics({\n      x: 1,\n      y: 1\n    });\n\n    this.maze = new GameMaze(this.game, this.graphics, this.settings.gridSize);\n\n    this.playerPos = {\n      x: 0,\n      y: 0\n    };\n\n    this.endPoint = {\n      x: this.settings.gridSize - 1,\n      y: this.settings.gridSize - 1\n    };\n\n    this.maze.drawMaze();\n\n    // Draw the endpoint\n    this.maze.fillGrid(this.endPoint, GRAY_0x);\n\n    // Draw the player\n    this.maze.fillGrid(this.playerPos, GOLD_0x);\n\n    this.timer = new Date().getTime();\n  }\n\n  handleGesture(gesture) {\n    if (gesture === GESTURES.SWIPE_LEFT) {\n      this.updateMovement(this.directions.LEFT);\n    } else if (gesture === GESTURES.SWIPE_RIGHT) {\n      this.updateMovement(this.directions.RIGHT);\n    } else if (gesture === GESTURES.SWIPE_UP) {\n      this.updateMovement(this.directions.UP);\n    } else if (gesture === GESTURES.SWIPE_DOWN) {\n      this.updateMovement(this.directions.DOWN);\n    }\n  }\n\n  updateMovement(direction) {\n    let prevPos = { ...this.playerPos };\n    if (direction === this.directions.UP) {\n      this.playerPos.y -= 1;\n      if (this.playerPos.y < 0) {\n        this.playerPos.y = 0;\n      }\n    } else if (direction === this.directions.DOWN) {\n      this.playerPos.y += 1;\n      if (this.playerPos.y > this.settings.gridSize - 1) {\n        this.playerPos.y = this.settings.gridSize - 1;\n      }\n    } else if (direction === this.directions.LEFT) {\n      this.playerPos.x -= 1;\n      if (this.playerPos.x < 0) {\n        this.playerPos.x = 0;\n      }\n    } else if (direction === this.directions.RIGHT) {\n      this.playerPos.x += 1;\n      if (this.playerPos.x > this.settings.gridSize - 1) {\n        this.playerPos.x = this.settings.gridSize - 1;\n      }\n    }\n    if (\n      this.maze.isEdge([\n        `${prevPos.x},${prevPos.y}`,\n        `${this.playerPos.x},${this.playerPos.y}`\n      ])\n    ) {\n      // Redraw player position\n      this.maze.fillGrid(prevPos, WHITE_0x);\n      this.maze.fillGrid(this.playerPos, GOLD_0x);\n    } else {\n      this.playerPos = prevPos;\n    }\n    // Check if player is in the finish position, if yes, finish game\n    if (\n      this.playerPos.x === this.endPoint.x &&\n      this.playerPos.y === this.endPoint.y\n    ) {\n      this.scene.start('EndScreen', {\n        settings: this.settings,\n        results: {\n          gameMode: 0,\n          time: Math.floor((new Date().getTime() - this.timer) / 1000)\n        }\n      });\n    }\n  }\n\n  update() {\n    if (Phaser.Input.Keyboard.JustDown(this.keys.exit)) {\n      this.scene.start('MainMenu', this.settings);\n    }\n\n    if (\n      Phaser.Input.Keyboard.JustDown(this.keys.up) ||\n      Phaser.Input.Keyboard.JustDown(this.keys.arrowUp)\n    ) {\n      this.updateMovement(this.directions.UP);\n    }\n\n    if (\n      Phaser.Input.Keyboard.JustDown(this.keys.down) ||\n      Phaser.Input.Keyboard.JustDown(this.keys.arrowDown)\n    ) {\n      this.updateMovement(this.directions.DOWN);\n    }\n\n    if (\n      Phaser.Input.Keyboard.JustDown(this.keys.left) ||\n      Phaser.Input.Keyboard.JustDown(this.keys.arrowLeft)\n    ) {\n      this.updateMovement(this.directions.LEFT);\n    }\n\n    if (\n      Phaser.Input.Keyboard.JustDown(this.keys.right) ||\n      Phaser.Input.Keyboard.JustDown(this.keys.arrowRight)\n    ) {\n      this.updateMovement(this.directions.RIGHT);\n    }\n  }\n}\n","import Phaser from 'phaser';\nimport { getDimensions } from '../Game/gameSettings';\nimport { BLACK, WHITE } from '../../common/colours';\nimport { GESTURES, gestureDetection } from '../Game/gestures';\n\nexport default class EndScreen extends Phaser.Scene {\n  constructor() {\n    super('EndScreen');\n  }\n\n  init(data) {\n    this.settings = data.settings;\n    this.results = data.results;\n    this.gameModes = {\n      SOLO: 0,\n      TWO_PLAYER: 1,\n      RACE: 2,\n      CHASE: 3,\n      ESCAPE: 4\n    };\n    this.handleGesture = this.handleGesture.bind(this);\n  }\n\n  create() {\n    this.cameras.main.setBackgroundColor(WHITE);\n    this.keys = this.input.keyboard.addKeys({\n      continue: 'Enter'\n    });\n    gestureDetection(this.input, this.handleGesture);\n\n    this.gameDimensions = getDimensions(this.game);\n\n    this.drawScreen();\n  }\n\n  drawScreen() {\n    let gameOver = this.add.text(\n      this.gameDimensions.screenCenter,\n      this.gameDimensions.screenSpaceUnit * 4,\n      'Game Over',\n      {\n        fontFamily: 'Ubuntu',\n        fill: BLACK,\n        fontSize: this.gameDimensions.textSize1\n      }\n    );\n    gameOver.setOrigin(0.5, 0.5);\n\n    if (this.results.gameMode === this.gameModes.SOLO) {\n      let time = this.add.text(\n        this.gameDimensions.screenCenter,\n        this.gameDimensions.screenSpaceUnit * 9,\n        `Time: ${this.results.time} s`,\n        {\n          fontFamily: 'Ubuntu',\n          fill: BLACK,\n          fontSize: this.gameDimensions.textSize2\n        }\n      );\n      time.setOrigin(0.5, 0.5);\n    } else if (this.results.gameMode === this.gameModes.TWO_PLAYER) {\n      // TODO...\n    }\n\n    let returnScreen = this.add.text(\n      this.gameDimensions.screenCenter,\n      this.gameDimensions.screenSpaceUnit * 15,\n      'Press enter to exit to menu.',\n      {\n        fontFamily: 'Ubuntu',\n        fill: BLACK,\n        fontSize: this.gameDimensions.textSize4\n      }\n    );\n    returnScreen.setOrigin(0.5, 0.5);\n  }\n\n  handleGesture(gesture) {\n    if (gesture === GESTURES.SINGLE_TAP) {\n      this.scene.start('MainMenu', this.settings);\n    }\n  }\n\n  update() {\n    if (Phaser.Input.Keyboard.JustDown(this.keys.continue)) {\n      this.scene.start('MainMenu', this.settings);\n    }\n  }\n}\n","import React from 'react';\nimport Phaser from 'phaser';\nimport Movement from './Scenes/Movement';\nimport MainMenu from './Scenes/MainMenu';\nimport Settings from './Scenes/Settings';\nimport StartGame from './Scenes/StartGame';\nimport EndScreen from './Scenes/EndScreen';\n\nexport default class Game extends React.Component {\n  componentDidMount() {\n    const dimension = this._getDimensions();\n    const config = {\n      type: Phaser.AUTO,\n      parent: 'phaser-parent',\n      pixelArt: true,\n      width: dimension * 0.8,\n      height: dimension * 0.8,\n      physics: {\n        default: 'arcade',\n        arcade: {\n          gravity: { y: 200 }\n        }\n      },\n      scene: [MainMenu, Movement, Settings, StartGame, EndScreen]\n    };\n\n    new Phaser.Game(config);\n  }\n\n  /**\n   * Returns the smaller of window.innerWidth and window.innerHeight\n   */\n  _getDimensions() {\n    let width = window.innerWidth;\n    let height = window.innerHeight;\n    if (width < height) {\n      return width;\n    } else {\n      return height;\n    }\n  }\n\n  render() {\n    return <div id=\"phaser-parent\" />;\n  }\n}\n","import React, { Component } from 'react';\nimport Game from './Phaser/Game';\nimport './App.css';\n\nclass App extends Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <Game />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","/**\n * https://stackoverflow.com/a/2450976\n */\nfunction shuffle(array) {\n  var currentIndex = array.length,\n    temporaryValue,\n    randomIndex;\n\n  // While there remain elements to shuffle...\n  while (0 !== currentIndex) {\n    // Pick a remaining element...\n    randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex -= 1;\n\n    // And swap it with the current element.\n    temporaryValue = array[currentIndex];\n    array[currentIndex] = array[randomIndex];\n    array[randomIndex] = temporaryValue;\n  }\n\n  return array;\n}\n\nmodule.exports = {\n  shuffle\n};\n"],"sourceRoot":""}