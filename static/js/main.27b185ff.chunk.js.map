{"version":3,"sources":["Phaser/src/Game/gameSettings.js","Phaser/src/Game/gestures.js","Phaser/src/Scenes/MainMenu.js","Phaser/src/Scenes/Settings.js","Phaser/src/Utils/graph.js","Phaser/src/Game/gameMaze.js","Phaser/src/Utils/maze.js","Phaser/src/Game/character.js","Phaser/src/Scenes/GamemodeSolo.js","Phaser/src/Scenes/GamemodeTwoPlayer.js","Phaser/src/Scenes/GamemodeRace.js","Phaser/src/Scenes/GamemodeChase.js","Phaser/src/Scenes/GamemodeEscape.js","Phaser/src/Scenes/EndScreen.js","Phaser/src/Game.js","App.js","serviceWorker.js","index.js","Phaser/src/Common/colours.js","Phaser/src/Common/shuffle.js"],"names":["GAMEMODES","SOLO","id","scene","text","TWO_PLAYER","RACE","CHASE","ESCAPE","getGamemodeInfo","getDimensions","game","screenLength","config","width","screenSpaceUnit","screenCenter","textSize1","textSize2","textSize3","textSize4","GESTURES","SWIPE_RIGHT","SWIPE_LEFT","SWIPE_UP","SWIPE_DOWN","SINGLE_TAP","DOUBLE_TAP","TP_SWIPE_RIGHT","NONE_DETECTED","gestureDetection","inputPlugin","callback","options","on","pointer","swipeThreshold","deltaTime","upTime","downTime","velX","upX","downX","velY","upY","downY","speedX","Math","abs","speedY","origin","x","y","gesture","detectGesture","MainMenu","data","this","settings","maxGridSize","minGridSize","gridSize","maxSideLength","minSideLength","sideLength","gameMode","handleGesture","bind","load","setBaseURL","cameras","main","setBackgroundColor","WHITE","keys","input","keyboard","addKeys","up","arrowUp","down","arrowDown","select","gameDimensions","choice","doubleTapTimer","doubleTapCooldown","add","fontFamily","fill","BLACK","fontSize","setOrigin","startGame","GOLD","GRAY","detection","updateChoice","Date","getTime","start","Phaser","Input","Keyboard","JustDown","direction","newChoice","length","setFill","Scene","Settings","left","arrowLeft","right","arrowRight","menuReturn","updateSelection","updateGridSize","updateGameMode","newGridSize","setText","newSideLength","newGameMode","Object","Graph","vertices","Set","edges","alist","forEach","v","addVertex","e","addEdge","key","vertex","Number","isInteger","push","isVertex","Error","has","Array","from","g","walk","i","isEdge","path","size","isWalk","GameMaze","graphics","colour","WHITE_0x","setPosition","fillStyle","maze","getVertices","pos","split","vertX","vertY","rectX","rectY","lengthX","lengthY","fillRect","position","_createGrid","_createMaze","floor","grid","j","completed","paths","shuffle","coords","map","parseInt","DIRECTIONS","UP","DOWN","LEFT","RIGHT","DEFAULT_UPDATE_STEPS","Character","prevPos","GOLD_0x","smoothMovement","UPDATE_STEPS","updateSteps","updating","updateStep","fillGrid","newPos","_smoothMovement","diffX","round","diffY","interFrom","interTo","GamemodeSolo","actionClock","actionCooldown","BLACK_0x","exit","character","endPoint","drawMaze","GRAY_0x","drawCharacter","timer","updateMovement","moveCharacter","finishTime","results","message","messageColour","isDown","update","GamemodeTwoPlayer","p1ActionClock","p2ActionClock","p1Up","p2Up","p1Down","p2Down","p1Left","p2Left","p1Right","p2Right","screenHalfway","positions","generateRandomPositions","p1InitialPosition","p1","p2InitialPosition","p2","p1EndPoint","p2EndPoint","player1","BLUE_0x","player2","GREEN_0x","furthestPoint","random","p1UpdateMovement","p2UpdateMovement","BLUE","GREEN","dateNow","isUpdating","GamemodeRace","continue","drawScreen","GamemodeChase","GamemodeEscape","EndScreen","Game","dimension","_getDimensions","type","AUTO","parent","pixelArt","height","physics","default","arcade","gravity","activePointers","window","innerWidth","innerHeight","React","Component","App","className","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","module","exports","array","temporaryValue","randomIndex","currentIndex"],"mappings":"gRAyCaA,EAAY,CACvBC,KAAM,CACJC,GAAI,EACJC,MAAO,eACPC,KAAM,QAERC,WAAY,CACVH,GAAI,EACJC,MAAO,oBACPC,KAAM,cAERE,KAAM,CACJJ,GAAI,EACJC,MAAO,eACPC,KAAM,QAERG,MAAO,CACLL,GAAI,EACJC,MAAO,gBACPC,KAAM,SAERI,OAAQ,CACNN,GAAI,EACJC,MAAO,iBACPC,KAAM,WASH,SAASK,EAAgBP,GAC9B,OAAW,IAAPA,EACKF,EAAUC,KACD,IAAPC,EACFF,EAAUK,WACD,IAAPH,EACFF,EAAUM,KACD,IAAPJ,EACFF,EAAUO,MACD,IAAPL,EACFF,EAAUQ,OAEV,GASJ,SAASE,EAAcC,GAC5B,IAAMC,EAAeD,EAAKE,OAAOC,MACjC,MAAO,CACLF,eACAG,gBAAiBH,EAAe,GAChCI,aAAcJ,EAAe,EAC7BK,UAAWL,EAAe,GAC1BM,UAAWN,EAAe,GAC1BO,UAAWP,EAAe,GAC1BQ,UAAWR,EAAe,I,WCvFjBS,EAAW,CACtBC,YAAa,EACbC,WAAY,EACZC,SAAU,EACVC,WAAY,EACZC,WAAY,EACZC,WAAY,EACZC,eAAgB,EAChBC,cAAe,GAWV,SAASC,EAAiBC,EAAaC,GAAyB,IAAfC,EAAc,uDAAJ,GAChEF,EAAYG,GAAG,aAAa,SAAAC,GAC1BH,EAWJ,SAAuBG,EAASF,GAC9B,IAAIG,EAAiBH,EAAQG,gBAAkB,IAC3CC,GAAaF,EAAQG,OAASH,EAAQI,UAAY,IAClDC,GAAQL,EAAQM,IAAMN,EAAQO,OAASL,EACvCM,GAAQR,EAAQS,IAAMT,EAAQU,OAASR,EACvCS,EAASC,KAAKC,IAAIR,GAClBS,EAASF,KAAKC,IAAIL,GAClBO,EAAS,CACXC,EAAGhB,EAAQO,MACXU,EAAGjB,EAAQU,OAEb,GAAIC,EAASG,GAAUH,EAASV,EAC9B,OAAII,EAAO,EACF,CACLa,QAAShC,EAASE,WAClB2B,OAAQA,GAGH,CACLG,QAAShC,EAASC,YAClB4B,OAAQA,GAGP,GAAID,EAASH,GAAUG,EAASb,EACrC,OAAIO,EAAO,EACF,CACLU,QAAShC,EAASG,SAClB0B,OAAQA,GAGH,CACLG,QAAShC,EAASI,WAClByB,OAAQA,GAId,MAAO,CACLG,QAAShC,EAASK,WAClBwB,OAAQA,GAjDCI,CAAcnB,EAASF,O,kOC7BfsB,E,YACnB,aAAe,qEACP,a,kEAGHC,GACHC,KAAKC,S,yVAAL,IFkGK,CACLC,YAAa,GACbC,YAAa,GACbC,SAAU,GACVC,cAAe,GACfC,cAAe,GACfC,WAAY,GACZC,SAAUjE,EAAUC,KAAKC,IEzGzB,GAAwCsD,GACxCC,KAAKS,cAAgBT,KAAKS,cAAcC,KAAKV,Q,gCAI7CA,KAAKW,KAAKC,WACR,+D,+BAMFZ,KAAKa,QAAQC,KAAKC,mBAAmBC,SACrChB,KAAKiB,KAAOjB,KAAKkB,MAAMC,SAASC,QAAQ,CACtCC,GAAI,IACJC,QAAS,KACTC,KAAM,IACNC,UAAW,OACXC,OAAQ,UAEVpD,EAAiB2B,KAAKkB,MAAOlB,KAAKS,eAElCT,KAAK0B,eAAiBzE,EAAc+C,KAAK9C,MAEzC8C,KAAK2B,OAAS,EAEd3B,KAAK4B,eAAiB,EACtB5B,KAAK6B,kBAAoB,IAEb7B,KAAK8B,IAAInF,KACnBqD,KAAK0B,eAAenE,aACkB,EAAtCyC,KAAK0B,eAAepE,gBACpB,mBACA,CACEyE,WAAY,SACZC,KAAMC,QACNC,SAAUlC,KAAK0B,eAAejE,YAG5B0E,UAAU,GAAK,IACrB,IAAIC,EAAYpC,KAAK8B,IAAInF,KACvBqD,KAAK0B,eAAenE,aACkB,EAAtCyC,KAAK0B,eAAepE,gBACpB,aACA,CACEyE,WAAY,SACZC,KAAMK,OACNH,SAAUlC,KAAK0B,eAAehE,YAGlC0E,EAAUD,UAAU,GAAK,IACzB,IAAIlC,EAAWD,KAAK8B,IAAInF,KACtBqD,KAAK0B,eAAenE,aACkB,GAAtCyC,KAAK0B,eAAepE,gBACpB,WACA,CACEyE,WAAY,SACZC,KAAMC,QACNC,SAAUlC,KAAK0B,eAAehE,YAGlCuC,EAASkC,UAAU,GAAK,IACbnC,KAAK8B,IAAInF,KAClBqD,KAAK0B,eAAenE,aACkB,GAAtCyC,KAAK0B,eAAepE,gBACpB,OACA,CACEyE,WAAY,SACZC,KAAMM,OACNJ,SAAUlC,KAAK0B,eAAehE,YAG7ByE,UAAU,GAAK,IAEpBnC,KAAKxB,QAAU,CACb,CAAE7B,KAAMyF,EAAW1F,MAAOM,EAAgBgD,KAAKC,SAASO,UAAU9D,OAClE,CAAEC,KAAMsD,EAAUvD,MAAO,e,oCAKf6F,GACRA,EAAU3C,UAAYhC,EAASG,SACjCiC,KAAKwC,cAAc,GACVD,EAAU3C,UAAYhC,EAASI,WACxCgC,KAAKwC,aAAa,GACTD,EAAU3C,UAAYhC,EAASK,cACpC,IAAIwE,MAAOC,UAAY1C,KAAK4B,eAAiB5B,KAAK6B,mBACpD7B,KAAKtD,MAAMiG,MAAM3C,KAAKxB,QAAQwB,KAAK2B,QAAQjF,MAAOsD,KAAKC,UAEzDD,KAAK4B,gBAAiB,IAAIa,MAAOC,a,gCAMjCE,IAAOC,MAAMC,SAASC,SAAS/C,KAAKiB,KAAKI,KACzCuB,IAAOC,MAAMC,SAASC,SAAS/C,KAAKiB,KAAKK,WAEzCtB,KAAKwC,cAAc,IAGnBI,IAAOC,MAAMC,SAASC,SAAS/C,KAAKiB,KAAKM,OACzCqB,IAAOC,MAAMC,SAASC,SAAS/C,KAAKiB,KAAKO,aAEzCxB,KAAKwC,aAAa,GAEhBI,IAAOC,MAAMC,SAASC,SAAS/C,KAAKiB,KAAKQ,SAC3CzB,KAAKtD,MAAMiG,MAAM3C,KAAKxB,QAAQwB,KAAK2B,QAAQjF,MAAOsD,KAAKC,Y,mCAI9C+C,GACX,IAAIC,EAAYjD,KAAK2B,OAASqB,EAC1BC,GAAa,GAAKA,EAAYjD,KAAKxB,QAAQ0E,SAC7ClD,KAAKxB,QAAQwB,KAAK2B,QAAQhF,KAAKwG,QAAQlB,SACvCjC,KAAKxB,QAAQyE,GAAWtG,KAAKwG,QAAQd,QACrCrC,KAAK2B,OAASsB,O,GA3HkBL,IAAOQ,OCHxBC,E,YACnB,aAAe,qEACP,a,kEAGHtD,GACHC,KAAKC,SAAWF,EAChBC,KAAKS,cAAgBT,KAAKS,cAAcC,KAAKV,Q,gCAI7CA,KAAKW,KAAKC,WACR,+D,+BAMFZ,KAAKa,QAAQC,KAAKC,mBAAmBC,SACrChB,KAAKiB,KAAOjB,KAAKkB,MAAMC,SAASC,QAAQ,CACtCC,GAAI,IACJC,QAAS,KACTC,KAAM,IACNC,UAAW,OACX8B,KAAM,IACNC,UAAW,OACXC,MAAO,IACPC,WAAY,QACZhC,OAAQ,UAEVpD,EAAiB2B,KAAKkB,MAAOlB,KAAKS,eAElCT,KAAK0B,eAAiBzE,EAAc+C,KAAK9C,MAEzC8C,KAAK2B,OAAS,EAEd3B,KAAK4B,eAAiB,EACtB5B,KAAK6B,kBAAoB,IAEb7B,KAAK8B,IAAInF,KACnBqD,KAAK0B,eAAenE,aACkB,EAAtCyC,KAAK0B,eAAepE,gBACpB,WACA,CACEyE,WAAY,SACZC,KAAMC,QACNC,SAAUlC,KAAK0B,eAAelE,YAG5B2E,UAAU,GAAK,IACrB,IAAI/B,EAAWJ,KAAK8B,IAAInF,KACtBqD,KAAK0B,eAAenE,aACkB,EAAtCyC,KAAK0B,eAAepE,gBAFP,qBAGC0C,KAAKC,SAASG,UAC5B,CACE2B,WAAY,SACZC,KAAMK,OACNH,SAAUlC,KAAK0B,eAAehE,YAGlC0C,EAAS+B,UAAU,GAAK,IACPnC,KAAK8B,IAAInF,KACxBqD,KAAK0B,eAAenE,aACkB,GAAtCyC,KAAK0B,eAAepE,gBAFL,uBAGC0C,KAAKC,SAASM,YAC9B,CACEwB,WAAY,SACZC,KAAMM,OACNJ,SAAUlC,KAAK0B,eAAehE,YAGvByE,UAAU,GAAK,IAC1B,IAAI3B,EAAWR,KAAK8B,IAAInF,KACtBqD,KAAK0B,eAAenE,aACkB,GAAtCyC,KAAK0B,eAAepE,gBACpBN,EAAgBgD,KAAKC,SAASO,UAAU7D,KACxC,CACEoF,WAAY,SACZC,KAAMC,QACNC,SAAUlC,KAAK0B,eAAehE,YAGlC8C,EAAS2B,UAAU,GAAK,IACxB,IAAIuB,EAAa1D,KAAK8B,IAAInF,KACxBqD,KAAK0B,eAAenE,aACkB,GAAtCyC,KAAK0B,eAAepE,gBACpB,SACA,CACEyE,WAAY,SACZC,KAAMC,QACNC,SAAUlC,KAAK0B,eAAehE,YAGlCgG,EAAWvB,UAAU,GAAK,IAE1BnC,KAAKxB,QAAU,CAAC4B,EAAUI,EAAUkD,K,oCAGxBnB,GACRA,EAAU3C,UAAYhC,EAASG,SACjCiC,KAAKwC,cAAc,GACVD,EAAU3C,UAAYhC,EAASI,WACxCgC,KAAKwC,aAAa,GACTD,EAAU3C,UAAYhC,EAASC,YACxCmC,KAAK2D,gBAAgB,GACZpB,EAAU3C,UAAYhC,EAASE,WACxCkC,KAAK2D,iBAAiB,GACbpB,EAAU3C,UAAYhC,EAASK,cACpC,IAAIwE,MAAOC,UAAY1C,KAAK4B,eAAiB5B,KAAK6B,mBAChC,IAAhB7B,KAAK2B,QACP3B,KAAKtD,MAAMiG,MAAM,WAAY3C,KAAKC,UAGtCD,KAAK4B,gBAAiB,IAAIa,MAAOC,a,gCAMjCE,IAAOC,MAAMC,SAASC,SAAS/C,KAAKiB,KAAKI,KACzCuB,IAAOC,MAAMC,SAASC,SAAS/C,KAAKiB,KAAKK,WAEzCtB,KAAKwC,cAAc,IAGnBI,IAAOC,MAAMC,SAASC,SAAS/C,KAAKiB,KAAKM,OACzCqB,IAAOC,MAAMC,SAASC,SAAS/C,KAAKiB,KAAKO,aAEzCxB,KAAKwC,aAAa,IAGlBI,IAAOC,MAAMC,SAASC,SAAS/C,KAAKiB,KAAKuC,QACzCZ,IAAOC,MAAMC,SAASC,SAAS/C,KAAKiB,KAAKwC,cAEzCzD,KAAK2D,gBAAgB,IAGrBf,IAAOC,MAAMC,SAASC,SAAS/C,KAAKiB,KAAKqC,OACzCV,IAAOC,MAAMC,SAASC,SAAS/C,KAAKiB,KAAKsC,aAEzCvD,KAAK2D,iBAAiB,GAEpBf,IAAOC,MAAMC,SAASC,SAAS/C,KAAKiB,KAAKQ,SACvB,IAAhBzB,KAAK2B,QACP3B,KAAKtD,MAAMiG,MAAM,WAAY3C,KAAKC,Y,mCAK3B+C,GACX,IAAIC,EAAYjD,KAAK2B,OAASqB,EAC1BC,GAAa,GAAKA,EAAYjD,KAAKxB,QAAQ0E,SAC7ClD,KAAKxB,QAAQwB,KAAK2B,QAAQwB,QAAQlB,SAClCjC,KAAKxB,QAAQyE,GAAWE,QAAQd,QAChCrC,KAAK2B,OAASsB,K,sCAIFD,GACM,IAAhBhD,KAAK2B,OACP3B,KAAK4D,eAAeZ,GACK,IAAhBhD,KAAK2B,QACd3B,KAAK6D,eAAeb,K,qCAOTA,GACb,IAAIc,EAAc9D,KAAKC,SAASG,SAAW4C,EAEzCc,EAAc9D,KAAKC,SAASE,YAAc,GAC1C2D,EAAc9D,KAAKC,SAASC,YAAc,IAE1CF,KAAKxB,QAAQ,GAAGuF,QAAhB,qBAAsCD,IACtC9D,KAAKC,SAASG,SAAW0D,K,uCAIZd,GACf,IAAIgB,EAAgBhE,KAAKC,SAASM,WAAayC,EAE7CgB,EAAgBhE,KAAKC,SAASK,cAAgB,GAC9C0D,EAAgBhE,KAAKC,SAASI,cAAgB,IAE9CL,KAAKxB,QAAQ,GAAGuF,QAAhB,uBAAwCC,IACxChE,KAAKC,SAASM,WAAayD,K,qCAIhBhB,GACb,IAAIiB,EAAcjE,KAAKC,SAASO,SAAWwC,EACvCiB,GAAe,GAAKA,EAAcC,OAAOjD,KAAK1E,GAAW2G,SAC3DlD,KAAKxB,QAAQ,GAAGuF,QAAQ/G,EAAgBiH,GAAatH,MACrDqD,KAAKC,SAASO,SAAWyD,O,GAnMOrB,IAAOQ,OCKxBe,E,WACnB,aAA+C,IAAD,OAAlCC,EAAkC,uDAAvB,IAAIC,IAAOC,EAAY,uDAAJ,GAAI,oBAC5CtE,KAAKuE,MAAQ,GAEbH,EAASI,SAAQ,SAAAC,GACf,EAAKC,UAAUD,MAEjBH,EAAME,SAAQ,SAAAG,GACZ,EAAKC,QAAQD,M,0DAKf,OAAO,IAAIN,IAAIH,OAAOjD,KAAKjB,KAAKuE,U,iCAGtB,IAAD,OACLD,EAAQ,GAUZ,OATAJ,OAAOjD,KAAKjB,KAAKuE,OAAOC,SAAQ,SAAAK,GAC9B,EAAKN,MAAMM,GAAKL,SAAQ,SAAAM,GAClBC,OAAOC,UAAUF,GACnBR,EAAMW,KAAK,CAACF,OAAOF,GAAMC,IAEzBR,EAAMW,KAAK,CAACJ,EAAKC,UAIhBR,I,gCAGCG,GACFA,KAAKzE,KAAKuE,QACdvE,KAAKuE,MAAME,GAAK,IAAIJ,O,8BAIhBM,GACN,IAAK3E,KAAKkF,SAASP,EAAE,MAAQ3E,KAAKkF,SAASP,EAAE,IAC3C,MAAM,IAAIQ,MAAM,+BAElBnF,KAAKuE,MAAMI,EAAE,IAAI7C,IAAI6C,EAAE,M,+BAGhBF,GACP,OAAOA,KAAKzE,KAAKuE,Q,6BAGZI,GACL,OAAMA,EAAE,KAAM3E,KAAKuE,OAGZvE,KAAKuE,MAAMI,EAAE,IAAIS,IAAIT,EAAE,M,iCAGrBF,GACT,IAAKzE,KAAKkF,SAAST,GACjB,MAAM,IAAIU,MAAM,uBAElB,OAAOE,MAAMC,KAAKtF,KAAKuE,MAAME,O,8BAGjBc,EAAGC,GACf,GAAoB,IAAhBA,EAAKtC,OAEP,OAAO,EAET,GAAoB,IAAhBsC,EAAKtC,OAAc,OAAOqC,EAAEL,SAASM,EAAK,IAE9C,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAKtC,OAAS,EAAGuC,IACnC,IAAKF,EAAEG,OAAO,CAACF,EAAKC,GAAID,EAAKC,EAAI,KAC/B,OAAO,EAGX,OAAO,I,6BAGKF,EAAGI,GACf,QAAI,IAAItB,IAAIsB,GAAMC,KAAOD,EAAKzC,SAEvBlD,KAAK6F,OAAON,EAAGI,O,cCtFLG,E,YAQnB,WAAY5I,EAAM6I,EAAUH,GAA0B,IAAD,EAAnBI,EAAmB,uDAAVC,WAAU,4BACnD,4CAAML,KACDA,KAAOA,EACZ,EAAK1I,KAAOA,EACZ,EAAK6I,SAAWA,EAChB,EAAKA,SAASG,YAAY,EAAG,GAC7B,EAAKxE,eAAiBzE,EAAc,EAAKC,MACzC,EAAKqD,YAAc,EAAKmB,eAAevE,aAAe,GAAKyI,EAC3D,EAAKI,OAASA,EARqC,E,wEAczC,IAAD,OACThG,KAAK+F,SAASI,UAAUnG,KAAKgG,QAC7BhG,KAAKoG,KAAKC,cAAc7B,SAAQ,SAAAM,GAC9B,IAAIwB,EAAMxB,EAAOyB,MAAM,KAEnBC,EAAQzB,OAAOuB,EAAI,IACnBG,EAAQ1B,OAAOuB,EAAI,IAEnBI,EAAQF,EAAQ,EAAKjG,WAAa,EAClCoG,EAAQF,EAAQ,EAAKlG,WAAa,EAClCqG,EAAU,EAAKrG,WAAa,EAC5BsG,EAAU,EAAKtG,WAAa,EAE5B,EAAK6F,KAAKV,OAAO,CAACZ,EAAD,UAAY0B,EAAQ,EAApB,YAAyBC,OAC5CC,GAAS,EACTE,GAAW,GAET,EAAKR,KAAKV,OAAO,CAACZ,EAAD,UAAY0B,EAAQ,EAApB,YAAyBC,OAC5CG,GAAW,GAET,EAAKR,KAAKV,OAAO,CAACZ,EAAD,UAAY0B,EAAZ,YAAqBC,EAAQ,OAChDE,GAAS,EACTE,GAAW,GAET,EAAKT,KAAKV,OAAO,CAACZ,EAAD,UAAY0B,EAAZ,YAAqBC,EAAQ,OAChDI,GAAW,GAGb,EAAKd,SAASe,SAASJ,EAAOC,EAAOC,EAASC,Q,+BAWzCE,EAAUf,GACjBhG,KAAK+F,SAASI,UAAUH,GACxBhG,KAAK+F,SAASe,SACZC,EAASrH,EAAIM,KAAKO,WAAa,EAC/BwG,EAASpH,EAAIK,KAAKO,WAAa,EAC/BP,KAAKO,WAAa,EAClBP,KAAKO,WAAa,O,cCnEtB,aAAuB,IAAXqF,EAAU,uDAAH,EAAG,oBACpB5F,KAAKoG,KAAOpG,KAAKgH,YAAYpB,GAC7B5F,KAAKiH,YAAL,UAAoB3H,KAAK4H,MAAMtB,EAAO,GAAtC,YAA4CtG,KAAK4H,MAAMtB,EAAO,K,0DAI9D,OAAO5F,KAAKoG,KAAKC,gB,6BAGZ1B,GACL,OAAO3E,KAAKoG,KAAKV,OAAOf,K,kCAGdiB,GAEV,IADA,IAAIuB,EAAO,IAAIhD,EACNsB,EAAI,EAAGA,EAAIG,EAAMH,IACxB,IAAK,IAAI2B,EAAI,EAAGA,EAAIxB,EAAMwB,IACxBD,EAAKzC,UAAL,UAAkBe,EAAlB,YAAuB2B,IAG3B,OAAOD,I,kCAGGrC,GAA4C,IAAD,OAAnCuC,EAAmC,uDAAvB,KAAMjD,EAAiB,uDAAN,KAC/B,MAAZA,IACFA,EAAWpE,KAAKqG,eAED,MAAbgB,IACFA,EAAY,IAAIhD,IAAIS,IAGtB,IAAIwC,EAAQC,kBAAQ,CAAC,KAAM,OAAQ,OAAQ,UAEvCC,EAAS1C,EAAOyB,MAAM,KAAKkB,KAAI,SAAAV,GACjC,OAAOW,SAASX,MAGd1F,EAAE,UAAMmG,EAAO,GAAb,YAAmBA,EAAO,GAAK,GACjCjG,EAAI,UAAMiG,EAAO,GAAb,YAAmBA,EAAO,GAAK,GACnClE,EAAI,UAAMkE,EAAO,GAAK,EAAlB,YAAuBA,EAAO,IAClChE,EAAK,UAAMgE,EAAO,GAAK,EAAlB,YAAuBA,EAAO,IAEvCF,EAAM9C,SAAQ,SAAAxB,GACM,OAAdA,EACEoB,EAASgB,IAAI/D,KAAQgG,EAAUjC,IAAI/D,KACrC,EAAK+E,KAAKxB,QAAQ,CAACE,EAAQzD,IAC3B,EAAK+E,KAAKxB,QAAQ,CAACvD,EAAIyD,IACvBuC,EAAUvF,IAAIT,GACd,EAAK4F,YAAY5F,EAAIgG,EAAWjD,IAEX,SAAdpB,EACLoB,EAASgB,IAAI7D,KAAU8F,EAAUjC,IAAI7D,KACvC,EAAK6E,KAAKxB,QAAQ,CAACE,EAAQvD,IAC3B,EAAK6E,KAAKxB,QAAQ,CAACrD,EAAMuD,IACzBuC,EAAUvF,IAAIP,GACd,EAAK0F,YAAY1F,EAAM8F,EAAWjD,IAEb,SAAdpB,EACLoB,EAASgB,IAAI9B,KAAU+D,EAAUjC,IAAI9B,KACvC,EAAK8C,KAAKxB,QAAQ,CAACE,EAAQxB,IAC3B,EAAK8C,KAAKxB,QAAQ,CAACtB,EAAMwB,IACzBuC,EAAUvF,IAAIwB,GACd,EAAK2D,YAAY3D,EAAM+D,EAAWjD,IAEb,UAAdpB,GACLoB,EAASgB,IAAI5B,KAAW6D,EAAUjC,IAAI5B,KACxC,EAAK4C,KAAKxB,QAAQ,CAACE,EAAQtB,IAC3B,EAAK4C,KAAKxB,QAAQ,CAACpB,EAAOsB,IAC1BuC,EAAUvF,IAAI0B,GACd,EAAKyD,YAAYzD,EAAO6D,EAAWjD,W,+jBCzD7C,IAAMuD,EAAa,CACjBC,GAAI,EACJC,KAAM,EACNC,KAAM,EACNC,MAAO,GAMHC,EAAuB,EAERC,E,WAYnB,WAAY7B,EAAMW,GAAyB,IAAfvI,EAAc,uDAAJ,GAAI,oBACxCwB,KAAKoG,KAAOA,EACZpG,KAAK+G,SAAWA,EAChB/G,KAAKkI,QAAUnB,EACf/G,KAAKgG,OAASxH,EAAQwH,QAAUmC,UAChCnI,KAAKoI,eAAiB5J,EAAQ4J,iBAAkB,EAChDpI,KAAKqI,aAAe7J,EAAQ8J,aAAeN,EAC3ChI,KAAKuI,UAAW,EAChBvI,KAAKwI,WAAa,E,4DAWlBxI,KAAKoG,KAAKqC,SAASzI,KAAK+G,SAAU/G,KAAKgG,U,oCAO3BhD,GAEZ,IAAIhD,KAAKuI,SAAT,CAIA,IAAIL,EAAO,KAAQlI,KAAK+G,UACpB2B,EAAM,KAAQ1I,KAAK+G,UACnB/D,IAAc2E,EAAWC,IAC3Bc,EAAO/I,GAAK,EACR+I,EAAO/I,EAAI,IACb+I,EAAO/I,EAAI,IAEJqD,IAAc2E,EAAWE,MAClCa,EAAO/I,GAAK,EACR+I,EAAO/I,EAAIK,KAAKoG,KAAKR,KAAO,IAC9B8C,EAAO/I,EAAIK,KAAKoG,KAAKR,KAAO,IAErB5C,IAAc2E,EAAWG,MAClCY,EAAOhJ,GAAK,EACRgJ,EAAOhJ,EAAI,IACbgJ,EAAOhJ,EAAI,IAEJsD,IAAc2E,EAAWI,QAClCW,EAAOhJ,GAAK,EACRgJ,EAAOhJ,EAAIM,KAAKoG,KAAKR,KAAO,IAC9B8C,EAAOhJ,EAAIM,KAAKoG,KAAKR,KAAO,IAI9B5F,KAAKoG,KAAKV,OAAO,CAAC,GAAD,OAAIwC,EAAQxI,EAAZ,YAAiBwI,EAAQvI,GAAzB,UAAiC+I,EAAOhJ,EAAxC,YAA6CgJ,EAAO/I,OAGrEK,KAAK+G,SAAW2B,EAChB1I,KAAKkI,QAAUA,EACXlI,KAAKoI,eAEPpI,KAAKuI,UAAW,GAEhBvI,KAAKoG,KAAKqC,SAASzI,KAAKkI,QAASlI,KAAKoG,KAAKJ,QAC3ChG,KAAKoG,KAAKqC,SAASzI,KAAK+G,SAAU/G,KAAKgG,a,+BASvChG,KAAKuI,UACPvI,KAAK2I,gBAAgB3I,KAAKkI,QAASlI,KAAK+G,Y,mCAS1C,OAAO/G,KAAKuI,W,wCAOZ,IAAIK,EAAQtJ,KAAKuJ,MAAM7I,KAAK+G,SAASrH,EAAIM,KAAKkI,QAAQxI,GAClDoJ,EAAQxJ,KAAKuJ,MAAM7I,KAAK+G,SAASpH,EAAIK,KAAKkI,QAAQvI,GACtD,GAAc,IAAViJ,EAAa,CAEf,IAAIG,EAAS,KACR/I,KAAKkI,QADG,CAEXxI,EACEJ,KAAKuJ,MAGD,IAFD7I,KAAKkI,QAAQxI,EACX,EAAIM,KAAKqI,aAAgBrI,KAAKwI,WAAaI,IAE5C,KAEJI,EAAO,KACNhJ,KAAKkI,QADC,CAETxI,EACEJ,KAAKuJ,MAGD,IAFD7I,KAAKkI,QAAQxI,EACX,EAAIM,KAAKqI,cAAiBrI,KAAKwI,WAAa,GAAKI,IAElD,KAER5I,KAAKoG,KAAKqC,SAASM,EAAW/I,KAAKoG,KAAKJ,QACxChG,KAAKoG,KAAKqC,SAASO,EAAShJ,KAAKgG,YAC5B,CACL,IAAI+C,EAAS,KACR/I,KAAKkI,QADG,CAEXvI,EACEL,KAAKuJ,MAGD,IAFD7I,KAAKkI,QAAQvI,EACX,EAAIK,KAAKqI,aAAgBrI,KAAKwI,WAAaM,IAE5C,KAEJE,EAAO,KACNhJ,KAAKkI,QADC,CAETvI,EACEL,KAAKuJ,MAGD,IAFD7I,KAAKkI,QAAQvI,EACX,EAAIK,KAAKqI,cAAiBrI,KAAKwI,WAAa,GAAKM,IAElD,KAER9I,KAAKoG,KAAKqC,SAASM,EAAW/I,KAAKoG,KAAKJ,QACxChG,KAAKoG,KAAKqC,SAASO,EAAShJ,KAAKgG,QAGnChG,KAAKwI,aACDxI,KAAKwI,WAAaxI,KAAKqI,eAAiB,IAC1CrI,KAAKwI,WAAa,EAClBxI,KAAKuI,UAAW,M,kCAlIlB,OAAOZ,M,KC7CUsB,E,YACnB,aAAe,qEACP,iB,kEAGHlJ,GACHC,KAAKC,SAAWF,EAChBC,KAAKS,cAAgBT,KAAKS,cAAcC,KAAKV,MAC7CA,KAAKkJ,YAAc,EACnBlJ,KAAKmJ,eAAiB,M,kEAQtBnJ,KAAKa,QAAQC,KAAKC,mBAAmBqI,YACrCpJ,KAAKiB,KAAOjB,KAAKkB,MAAMC,SAASC,QAAQ,CACtCC,GAAI,IACJC,QAAS,KACTC,KAAM,IACNC,UAAW,OACX8B,KAAM,IACNC,UAAW,OACXC,MAAO,IACPC,WAAY,QACZ4F,KAAM,QAERhL,EAAiB2B,KAAKkB,MAAOlB,KAAKS,eAElCT,KAAK+F,SAAW/F,KAAK8B,IAAIiE,WAEzB/F,KAAKoG,KAAO,IAAIN,EAAS9F,KAAK9C,KAAM8C,KAAK+F,SAAU/F,KAAKC,SAASG,UAMjEJ,KAAKsJ,UAAY,IAAIrB,EAAUjI,KAAKoG,KAJd,CACpB1G,EAAG,EACHC,EAAG,GAEsD,CACzDyI,gBAAgB,IAGlBpI,KAAKuJ,SAAW,CACd7J,EAAGM,KAAKC,SAASG,SAAW,EAC5BT,EAAGK,KAAKC,SAASG,SAAW,GAG9BJ,KAAKoG,KAAKoD,WAGVxJ,KAAKoG,KAAKqC,SAASzI,KAAKuJ,SAAUE,WAGlCzJ,KAAKsJ,UAAUI,gBAEf1J,KAAK2J,OAAQ,IAAIlH,MAAOC,Y,oCAGZH,GACRA,EAAU3C,UAAYhC,EAASE,WACjCkC,KAAK4J,eAAe3B,EAAUN,WAAWG,MAChCvF,EAAU3C,UAAYhC,EAASC,YACxCmC,KAAK4J,eAAe3B,EAAUN,WAAWI,OAChCxF,EAAU3C,UAAYhC,EAASG,SACxCiC,KAAK4J,eAAe3B,EAAUN,WAAWC,IAChCrF,EAAU3C,UAAYhC,EAASI,YACxCgC,KAAK4J,eAAe3B,EAAUN,WAAWE,Q,qCAI9B7E,GAIb,GAFAhD,KAAKsJ,UAAUO,cAAc7G,GAG3BhD,KAAKsJ,UAAUvC,SAASrH,IAAMM,KAAKuJ,SAAS7J,GAC5CM,KAAKsJ,UAAUvC,SAASpH,IAAMK,KAAKuJ,SAAS5J,EAC5C,CACA,IAAImK,EAAaxK,KAAK4H,QAAO,IAAIzE,MAAOC,UAAY1C,KAAK2J,OAAS,KAClE3J,KAAKtD,MAAMiG,MAAM,YAAa,CAC5B1C,SAAUD,KAAKC,SACf8J,QAAS,CACPvJ,SAAUjE,EAAUC,KAAKC,GACzBuN,QAAQ,SAAD,OAAWF,EAAX,MACPG,cAAehI,c,+BAOjBW,IAAOC,MAAMC,SAASC,SAAS/C,KAAKiB,KAAKoI,OAC3CrJ,KAAKtD,MAAMiG,MAAM,WAAY3C,KAAKC,WAGhC,IAAIwC,MAAOC,UAAY1C,KAAKkJ,YAAclJ,KAAKmJ,iBAC7CnJ,KAAKiB,KAAKI,GAAG6I,QAAUlK,KAAKiB,KAAKK,QAAQ4I,QAC3ClK,KAAK4J,eAAe3B,EAAUN,WAAWC,IACzC5H,KAAKkJ,aAAc,IAAIzG,MAAOC,WACrB1C,KAAKiB,KAAKM,KAAK2I,QAAUlK,KAAKiB,KAAKO,UAAU0I,QACtDlK,KAAK4J,eAAe3B,EAAUN,WAAWE,MACzC7H,KAAKkJ,aAAc,IAAIzG,MAAOC,WACrB1C,KAAKiB,KAAKqC,KAAK4G,QAAUlK,KAAKiB,KAAKsC,UAAU2G,QACtDlK,KAAK4J,eAAe3B,EAAUN,WAAWG,MACzC9H,KAAKkJ,aAAc,IAAIzG,MAAOC,YACrB1C,KAAKiB,KAAKuC,MAAM0G,QAAUlK,KAAKiB,KAAKwC,WAAWyG,UACxDlK,KAAK4J,eAAe3B,EAAUN,WAAWI,OACzC/H,KAAKkJ,aAAc,IAAIzG,MAAOC,YAIlC1C,KAAKsJ,UAAUa,a,GAhHuBvH,IAAOQ,OCA5BgH,E,YACnB,aAAe,qEACP,sB,kEAGHrK,GACHC,KAAKC,SAAWF,EAChBC,KAAKS,cAAgBT,KAAKS,cAAcC,KAAKV,MAC7CA,KAAKqK,cAAgB,EACrBrK,KAAKsK,cAAgB,EACrBtK,KAAKmJ,eAAiB,M,kEAQtBnJ,KAAKa,QAAQC,KAAKC,mBAAmBqI,YACrCpJ,KAAKiB,KAAOjB,KAAKkB,MAAMC,SAASC,QAAQ,CACtCmJ,KAAM,KACNC,KAAM,IACNC,OAAQ,OACRC,OAAQ,IACRC,OAAQ,OACRC,OAAQ,IACRC,QAAS,QACTC,QAAS,IACTzB,KAAM,QAERrJ,KAAK+K,cAAgB/K,KAAK9C,KAAKE,OAAOC,MAAQ,EAC9CgB,EAAiB2B,KAAKkB,MAAOlB,KAAKS,eAElCT,KAAK+F,SAAW/F,KAAK8B,IAAIiE,WAEzB/F,KAAKoG,KAAO,IAAIN,EAAS9F,KAAK9C,KAAM8C,KAAK+F,SAAU/F,KAAKC,SAASG,UAEjE,IAAI4K,EAAYhL,KAAKiL,0BAEjBC,EAAoBF,EAAUG,GAC9BC,EAAoBJ,EAAUK,GAClCrL,KAAKsL,WAAaN,EAAUK,GAC5BrL,KAAKuL,WAAaP,EAAUG,GAE5BnL,KAAKwL,QAAU,IAAIvD,EAAUjI,KAAKoG,KAAM8E,EAAmB,CACzD9C,gBAAgB,EAChBpC,OAAQyF,YAEVzL,KAAK0L,QAAU,IAAIzD,EAAUjI,KAAKoG,KAAMgF,EAAmB,CACzDhD,gBAAgB,EAChBpC,OAAQ2F,aAGV3L,KAAKoG,KAAKoD,WAGVxJ,KAAKwL,QAAQ9B,gBACb1J,KAAK0L,QAAQhC,gBAEb1J,KAAK2J,OAAQ,IAAIlH,MAAOC,Y,gDAIxB,IAAIkJ,EAAgB5L,KAAKC,SAASG,SAAW,EA0C7C,MADgB,CAxCA,CACd+K,GAAI,CACFzL,EAAG,EACHC,EAAG,GAEL0L,GAAI,CACF3L,EAAGkM,EACHjM,EAAGiM,IAGS,CACdT,GAAI,CACFzL,EAAGkM,EACHjM,EAAG,GAEL0L,GAAI,CACF3L,EAAG,EACHC,EAAGiM,IAGS,CACdT,GAAI,CACFzL,EAAG,EACHC,EAAGiM,GAELP,GAAI,CACF3L,EAAGkM,EACHjM,EAAG,IAGS,CACdwL,GAAI,CACFzL,EAAGkM,EACHjM,EAAGiM,GAELP,GAAI,CACF3L,EAAG,EACHC,EAAG,KAIUL,KAAK4H,MAAsB,EAAhB5H,KAAKuM,a,oCAGrBtJ,GACRA,EAAU3C,UAAYhC,EAASE,WAC7ByE,EAAU9C,OAAOE,EAAIK,KAAK+K,cAC5B/K,KAAK8L,iBAAiB7D,EAAUN,WAAWG,MAE3C9H,KAAK+L,iBAAiB9D,EAAUN,WAAWG,MAEpCvF,EAAU3C,UAAYhC,EAASC,YACpC0E,EAAU9C,OAAOE,EAAIK,KAAK+K,cAC5B/K,KAAK8L,iBAAiB7D,EAAUN,WAAWI,OAE3C/H,KAAK+L,iBAAiB9D,EAAUN,WAAWI,OAEpCxF,EAAU3C,UAAYhC,EAASG,SACpCwE,EAAU9C,OAAOE,EAAIK,KAAK+K,cAC5B/K,KAAK8L,iBAAiB7D,EAAUN,WAAWC,IAE3C5H,KAAK+L,iBAAiB9D,EAAUN,WAAWC,IAEpCrF,EAAU3C,UAAYhC,EAASI,aACpCuE,EAAU9C,OAAOE,EAAIK,KAAK+K,cAC5B/K,KAAK8L,iBAAiB7D,EAAUN,WAAWE,MAE3C7H,KAAK+L,iBAAiB9D,EAAUN,WAAWE,S,uCAKhC7E,GAEfhD,KAAKwL,QAAQ3B,cAAc7G,GAGzBhD,KAAKwL,QAAQzE,SAASrH,IAAMM,KAAKsL,WAAW5L,GAC5CM,KAAKwL,QAAQzE,SAASpH,IAAMK,KAAKsL,WAAW3L,GAE5CK,KAAKtD,MAAMiG,MAAM,YAAa,CAC5B1C,SAAUD,KAAKC,SACf8J,QAAS,CACPvJ,SAAUjE,EAAUK,WAAWH,GAC/BuN,QAAS,iBACTC,cAAe+B,Y,uCAMNhJ,GAEfhD,KAAK0L,QAAQ7B,cAAc7G,GAGzBhD,KAAK0L,QAAQ3E,SAASrH,IAAMM,KAAKuL,WAAW7L,GAC5CM,KAAK0L,QAAQ3E,SAASpH,IAAMK,KAAKuL,WAAW5L,GAE5CK,KAAKtD,MAAMiG,MAAM,YAAa,CAC5B1C,SAAUD,KAAKC,SACf8J,QAAS,CACPvJ,SAAUjE,EAAUK,WAAWH,GAC/BuN,QAAS,iBACTC,cAAegC,a,+BAOjBrJ,IAAOC,MAAMC,SAASC,SAAS/C,KAAKiB,KAAKoI,OAC3CrJ,KAAKtD,MAAMiG,MAAM,WAAY3C,KAAKC,UAGpC,IAAIiM,GAAU,IAAIzJ,MAAOC,UAErBwJ,EAAUlM,KAAKqK,cAAgBrK,KAAKmJ,iBAClCnJ,KAAKiB,KAAKsJ,KAAKL,QACjBlK,KAAK8L,iBAAiB7D,EAAUN,WAAWC,IAC3C5H,KAAKqK,eAAgB,IAAI5H,MAAOC,WACvB1C,KAAKiB,KAAKwJ,OAAOP,QAC1BlK,KAAK8L,iBAAiB7D,EAAUN,WAAWE,MAC3C7H,KAAKqK,eAAgB,IAAI5H,MAAOC,WACvB1C,KAAKiB,KAAK0J,OAAOT,QAC1BlK,KAAK8L,iBAAiB7D,EAAUN,WAAWG,MAC3C9H,KAAKqK,eAAgB,IAAI5H,MAAOC,WACvB1C,KAAKiB,KAAK4J,QAAQX,SAC3BlK,KAAK8L,iBAAiB7D,EAAUN,WAAWI,OAC3C/H,KAAKqK,eAAgB,IAAI5H,MAAOC,YAIhCwJ,EAAUlM,KAAKsK,cAAgBtK,KAAKmJ,iBAClCnJ,KAAKiB,KAAKuJ,KAAKN,QACjBlK,KAAK+L,iBAAiB9D,EAAUN,WAAWC,IAC3C5H,KAAKsK,eAAgB,IAAI7H,MAAOC,WACvB1C,KAAKiB,KAAKyJ,OAAOR,QAC1BlK,KAAK+L,iBAAiB9D,EAAUN,WAAWE,MAC3C7H,KAAKsK,eAAgB,IAAI7H,MAAOC,WACvB1C,KAAKiB,KAAK2J,OAAOV,QAC1BlK,KAAK+L,iBAAiB9D,EAAUN,WAAWG,MAC3C9H,KAAKsK,eAAgB,IAAI7H,MAAOC,WACvB1C,KAAKiB,KAAK6J,QAAQZ,SAC3BlK,KAAK+L,iBAAiB9D,EAAUN,WAAWI,OAC3C/H,KAAKsK,eAAgB,IAAI7H,MAAOC,YAIpC1C,KAAKwL,QAAQrB,SACbnK,KAAK0L,QAAQvB,SACRnK,KAAKwL,QAAQW,eAEhBnM,KAAKoG,KAAKqC,SAASzI,KAAKuL,WAAYI,YACpC3L,KAAKwL,QAAQ9B,iBAEV1J,KAAK0L,QAAQS,eAChBnM,KAAKoG,KAAKqC,SAASzI,KAAKsL,WAAYG,WACpCzL,KAAK0L,QAAQhC,qB,GA9N4B9G,IAAOQ,OCFjCgJ,E,YACnB,aAAe,qEACP,iB,kEAGHrM,GACHC,KAAKC,SAAWF,EAAKE,SACrBD,KAAKS,cAAgBT,KAAKS,cAAcC,KAAKV,Q,+BAI7CA,KAAKa,QAAQC,KAAKC,mBAAmBC,SACrChB,KAAKiB,KAAOjB,KAAKkB,MAAMC,SAASC,QAAQ,CACtCiL,SAAU,UAEZhO,EAAiB2B,KAAKkB,MAAOlB,KAAKS,eAElCT,KAAK0B,eAAiBzE,EAAc+C,KAAK9C,MAEzC8C,KAAKsM,e,mCAIiBtM,KAAK8B,IAAInF,KAC7BqD,KAAK0B,eAAenE,aACkB,EAAtCyC,KAAK0B,eAAepE,gBACpB,aACA,CACEyE,WAAY,SACZC,KAAMC,QACNC,SAAUlC,KAAK0B,eAAelE,YAGlB2E,UAAU,GAAK,M,oCAGnBI,GACRA,EAAU3C,UAAYhC,EAASK,YACjC+B,KAAKtD,MAAMiG,MAAM,WAAY3C,KAAKC,Y,+BAKhC2C,IAAOC,MAAMC,SAASC,SAAS/C,KAAKiB,KAAKoL,WAC3CrM,KAAKtD,MAAMiG,MAAM,WAAY3C,KAAKC,c,GA5CE2C,IAAOQ,OCA5BmJ,E,YACnB,aAAe,qEACP,kB,kEAGHxM,GACHC,KAAKC,SAAWF,EAAKE,SACrBD,KAAKS,cAAgBT,KAAKS,cAAcC,KAAKV,Q,+BAI7CA,KAAKa,QAAQC,KAAKC,mBAAmBC,SACrChB,KAAKiB,KAAOjB,KAAKkB,MAAMC,SAASC,QAAQ,CACtCiL,SAAU,UAEZhO,EAAiB2B,KAAKkB,MAAOlB,KAAKS,eAElCT,KAAK0B,eAAiBzE,EAAc+C,KAAK9C,MAEzC8C,KAAKsM,e,mCAIiBtM,KAAK8B,IAAInF,KAC7BqD,KAAK0B,eAAenE,aACkB,EAAtCyC,KAAK0B,eAAepE,gBACpB,cACA,CACEyE,WAAY,SACZC,KAAMC,QACNC,SAAUlC,KAAK0B,eAAelE,YAGlB2E,UAAU,GAAK,M,oCAGnBI,GACRA,EAAU3C,UAAYhC,EAASK,YACjC+B,KAAKtD,MAAMiG,MAAM,WAAY3C,KAAKC,Y,+BAKhC2C,IAAOC,MAAMC,SAASC,SAAS/C,KAAKiB,KAAKoL,WAC3CrM,KAAKtD,MAAMiG,MAAM,WAAY3C,KAAKC,c,GA5CG2C,IAAOQ,OCA7BoJ,E,YACnB,aAAe,qEACP,mB,kEAGHzM,GACHC,KAAKC,SAAWF,EAAKE,SACrBD,KAAKS,cAAgBT,KAAKS,cAAcC,KAAKV,Q,+BAI7CA,KAAKa,QAAQC,KAAKC,mBAAmBC,SACrChB,KAAKiB,KAAOjB,KAAKkB,MAAMC,SAASC,QAAQ,CACtCiL,SAAU,UAEZhO,EAAiB2B,KAAKkB,MAAOlB,KAAKS,eAElCT,KAAK0B,eAAiBzE,EAAc+C,KAAK9C,MAEzC8C,KAAKsM,e,mCAIiBtM,KAAK8B,IAAInF,KAC7BqD,KAAK0B,eAAenE,aACkB,EAAtCyC,KAAK0B,eAAepE,gBACpB,eACA,CACEyE,WAAY,SACZC,KAAMC,QACNC,SAAUlC,KAAK0B,eAAelE,YAGlB2E,UAAU,GAAK,M,oCAGnBI,GACRA,EAAU3C,UAAYhC,EAASK,YACjC+B,KAAKtD,MAAMiG,MAAM,WAAY3C,KAAKC,Y,+BAKhC2C,IAAOC,MAAMC,SAASC,SAAS/C,KAAKiB,KAAKoL,WAC3CrM,KAAKtD,MAAMiG,MAAM,WAAY3C,KAAKC,c,GA5CI2C,IAAOQ,OCA9BqJ,E,YACnB,aAAe,qEACP,c,kEAGH1M,GACHC,KAAKC,SAAWF,EAAKE,SACrBD,KAAK+J,QAAUhK,EAAKgK,QACpB/J,KAAKS,cAAgBT,KAAKS,cAAcC,KAAKV,Q,+BAI7CA,KAAKa,QAAQC,KAAKC,mBAAmBC,SACrChB,KAAKiB,KAAOjB,KAAKkB,MAAMC,SAASC,QAAQ,CACtCiL,SAAU,UAEZhO,EAAiB2B,KAAKkB,MAAOlB,KAAKS,eAElCT,KAAK0B,eAAiBzE,EAAc+C,KAAK9C,MAEzC8C,KAAKsM,e,mCAIUtM,KAAK8B,IAAInF,KACtBqD,KAAK0B,eAAenE,aACkB,EAAtCyC,KAAK0B,eAAepE,gBACpB,YACA,CACEyE,WAAY,SACZC,KAAMC,QACNC,SAAUlC,KAAK0B,eAAelE,YAGzB2E,UAAU,GAAK,IAEVnC,KAAK8B,IAAInF,KACrBqD,KAAK0B,eAAenE,aACkB,EAAtCyC,KAAK0B,eAAepE,gBACpB0C,KAAK+J,QAAQC,QACb,CACEjI,WAAY,SACZC,KAAMhC,KAAK+J,QAAQE,cACnB/H,SAAUlC,KAAK0B,eAAejE,YAG1B0E,UAAU,GAAK,IAEJnC,KAAK8B,IAAInF,KAC1BqD,KAAK0B,eAAenE,aACkB,GAAtCyC,KAAK0B,eAAepE,gBACpB,+BACA,CACEyE,WAAY,SACZC,KAAMC,QACNC,SAAUlC,KAAK0B,eAAe/D,YAGrBwE,UAAU,GAAK,M,oCAGhBI,GACRA,EAAU3C,UAAYhC,EAASK,YACjC+B,KAAKtD,MAAMiG,MAAM,WAAY3C,KAAKC,Y,+BAKhC2C,IAAOC,MAAMC,SAASC,SAAS/C,KAAKiB,KAAKoL,WAC3CrM,KAAKtD,MAAMiG,MAAM,WAAY3C,KAAKC,c,GArED2C,IAAOQ,OCMzBsJ,E,4LAEjB,IAAMC,EAAY3M,KAAK4M,iBACjBxP,EAAS,CACbyP,KAAMjK,IAAOkK,KACbC,OAAQ,gBACRC,UAAU,EACV3P,MAAmB,GAAZsP,EACPM,OAAoB,GAAZN,EACRO,QAAS,CACPC,QAAS,SACTC,OAAQ,CACNC,QAAS,CAAE1N,EAAG,OAGlBuB,MAAO,CACLoM,eAAgB,GAElB5Q,MAAO,CACLoD,EACAuD,EACA4F,EACAmB,EACAgC,EACAG,EACAC,EACAC,IAIJ,IAAI7J,IAAO8J,KAAKtP,K,uCAOhB,IAAIC,EAAQkQ,OAAOC,WACfP,EAASM,OAAOE,YACpB,OAAIpQ,EAAQ4P,EACH5P,EAEA4P,I,+BAKT,OAAO,yBAAKxQ,GAAG,sB,GA/CeiR,IAAMC,WCGzBC,G,yLARX,OACE,yBAAKC,UAAU,OACb,kBAAC,EAAD,W,GAJUF,cCQEG,QACW,cAA7BP,OAAOQ,SAASC,UAEe,UAA7BT,OAAOQ,SAASC,UAEhBT,OAAOQ,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,SD2H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,MAAK,SAAAC,GACjCA,EAAaC,iB,gBEpHnBC,EAAOC,QAAU,CACf5M,MAhBY,UAiBZmH,SATe,WAUf/G,KAjBW,UAkBX8F,QAVc,WAWd7F,KAjBW,UAkBXmH,QAVc,WAWdzI,MApBY,UAqBZiF,SAbe,WAcf+F,KApBW,UAqBXP,QAbc,WAcdQ,MArBY,UAsBZN,SAde,a,kBCUjBiD,EAAOC,QAAU,CACftH,QArBF,SAAiBuH,GAMf,IALA,IACEC,EACAC,EAFEC,EAAeH,EAAM5L,OAKlB,IAAM+L,GAEXD,EAAc1P,KAAK4H,MAAM5H,KAAKuM,SAAWoD,GAIzCF,EAAiBD,EAHjBG,GAAgB,GAIhBH,EAAMG,GAAgBH,EAAME,GAC5BF,EAAME,GAAeD,EAGvB,OAAOD,K","file":"static/js/main.27b185ff.chunk.js","sourcesContent":["/**\n * @typedef {Object} GameSettings\n * @property {Number} maxGridSize\n * @property {Number} minGridSize\n * @property {Number} gridSize\n * @property {Number} maxSideLength\n * @property {Number} minSideLength\n * @property {Number} sideLength\n * @property {Number} gameMode\n */\n\n/**\n * @typedef {Object} GamemodeInfo\n * @property {Number} id - Gamemode ID\n * @property {String} scene - Gamemode scene\n * @property {String} text - Gamemode display text\n */\n\n/**\n * @typedef {Object} Gamemode\n * @property {Object} SOLO - Solo\n * @property {Number} SOLO.id\n * @property {String} SOLO.scene\n * @property {String} SOLO.text\n * @property {Number} TWO_PLAYER - Two Player\n * @property {Number} TWO_PLAYER.id\n * @property {String} TWO_PLAYER.scene\n * @property {String} TWO_PLAYER.text\n * @property {Number} RACE - Race\n * @property {Number} RACE.id\n * @property {String} RACE.scene\n * @property {String} RACE.text\n * @property {Number} CHASE - Chase\n * @property {Number} CHASE.id\n * @property {String} CHASE.scene\n * @property {String} CHASE.text\n * @property {Number} ESCAPE - Escape\n * @property {Number} ESCAPE.id\n * @property {String} ESCAPE.scene\n * @property {String} ESCAPE.text\n */\nexport const GAMEMODES = {\n  SOLO: {\n    id: 0,\n    scene: 'GamemodeSolo',\n    text: 'Solo'\n  },\n  TWO_PLAYER: {\n    id: 1,\n    scene: 'GamemodeTwoPlayer',\n    text: 'Two Player'\n  },\n  RACE: {\n    id: 2,\n    scene: 'GamemodeRace',\n    text: 'Race'\n  },\n  CHASE: {\n    id: 3,\n    scene: 'GamemodeChase',\n    text: 'Chase'\n  },\n  ESCAPE: {\n    id: 4,\n    scene: 'GamemodeEscape',\n    text: 'Escape'\n  }\n};\n\n/**\n *\n * @param {Number} id - The gamemode ID\n * @returns {GamemodeInfo}\n */\nexport function getGamemodeInfo(id) {\n  if (id === 0) {\n    return GAMEMODES.SOLO;\n  } else if (id === 1) {\n    return GAMEMODES.TWO_PLAYER;\n  } else if (id === 2) {\n    return GAMEMODES.RACE;\n  } else if (id === 3) {\n    return GAMEMODES.CHASE;\n  } else if (id === 4) {\n    return GAMEMODES.ESCAPE;\n  } else {\n    return {};\n  }\n}\n\n/**\n * Returns custom dimensions for the game instance\n * @param {Phaser.Game} game - The Phaser Game object\n * @returns {Object} - The custom dimensions object\n */\nexport function getDimensions(game) {\n  const screenLength = game.config.width;\n  return {\n    screenLength,\n    screenSpaceUnit: screenLength / 20,\n    screenCenter: screenLength / 2,\n    textSize1: screenLength / 10,\n    textSize2: screenLength / 15,\n    textSize3: screenLength / 18,\n    textSize4: screenLength / 22\n  };\n}\n\n/**\n * The initial settings for the game (game configs)\n * @returns {GameSettings} - The initial/default settings for the game configurations\n */\nexport function initSettings() {\n  return {\n    maxGridSize: 35,\n    minGridSize: 10,\n    gridSize: 20,\n    maxSideLength: 15,\n    minSideLength: 10,\n    sideLength: 10,\n    gameMode: GAMEMODES.SOLO.id\n  };\n}\n","/**\n * @typedef {Object} Detection - The detected gesture and its origin\n * @property {Gesture} gesture\n * @property {Object} origin - The position the gesture was initiated\n * @property {Number} origin.x\n * @property {Number} origin.y\n */\n\n/**\n * @typedef {Object} Gesture\n * @property {Number} SWIPE_RIGHT\n * @property {Number} SWIPE_LEFT\n * @property {Number} SWIPE_UP\n * @property {Number} SWIPE_DOWN\n * @property {Number} SINGLE_TAP\n * @property {Number} NONE_DETECTED\n */\nexport const GESTURES = {\n  SWIPE_RIGHT: 0,\n  SWIPE_LEFT: 1,\n  SWIPE_UP: 2,\n  SWIPE_DOWN: 3,\n  SINGLE_TAP: 4,\n  DOUBLE_TAP: 5, // Not sure if this can be implemented here (maybe separately)\n  TP_SWIPE_RIGHT: 6, // TP = Two Pointer... (WIP)\n  NONE_DETECTED: 7\n};\n\n/**\n * Register input plugin for gesture detection\n * @param {Phaser.Input.InputPlugin} inputPlugin - The input plugin that handles all input related events\n * @callback callback - The callback function that handles the detected gesture\n *  @param {Detection} detection - The detected gesture\n * @param {Object} [options]\n * @param {Number} [options.swipeThreshold] - The swipe threshold for the detection\n */\nexport function gestureDetection(inputPlugin, callback, options = {}) {\n  inputPlugin.on('pointerup', pointer => {\n    callback(detectGesture(pointer, options));\n  });\n}\n\n/**\n * Detects a gesture based on the given Phaser Pointer object\n * @param {Phaser.Input.Pointer} pointer - The Phaser Pointer object\n * @param {Object} [options]\n * @param {Number} [options.swipeThreshold] - The swipe threshold for the detection\n * @returns {Detection}\n */\nfunction detectGesture(pointer, options) {\n  let swipeThreshold = options.swipeThreshold || 100;\n  let deltaTime = (pointer.upTime - pointer.downTime) / 1000;\n  let velX = (pointer.upX - pointer.downX) / deltaTime;\n  let velY = (pointer.upY - pointer.downY) / deltaTime;\n  let speedX = Math.abs(velX);\n  let speedY = Math.abs(velY);\n  let origin = {\n    x: pointer.downX,\n    y: pointer.downY\n  };\n  if (speedX > speedY && speedX > swipeThreshold) {\n    if (velX < 0) {\n      return {\n        gesture: GESTURES.SWIPE_LEFT,\n        origin: origin\n      };\n    } else {\n      return {\n        gesture: GESTURES.SWIPE_RIGHT,\n        origin: origin\n      };\n    }\n  } else if (speedY > speedX && speedY > swipeThreshold) {\n    if (velY < 0) {\n      return {\n        gesture: GESTURES.SWIPE_UP,\n        origin: origin\n      };\n    } else {\n      return {\n        gesture: GESTURES.SWIPE_DOWN,\n        origin: origin\n      };\n    }\n  }\n  return {\n    gesture: GESTURES.SINGLE_TAP,\n    origin: origin\n  };\n}\n\n// Swipe gestures without using time (speed/velocity)\n// eslint-disable-next-line\nfunction detectGestureNoTime(pointer, options) {\n  let swipeThreshold = options.swipeThreshold || 50;\n  let displacementX = pointer.upX - pointer.downX;\n  let displacementY = pointer.upY - pointer.downY;\n  let distanceX = Math.abs(displacementX);\n  let distanceY = Math.abs(displacementY);\n  if (distanceX > distanceY && distanceX > swipeThreshold) {\n    if (displacementX < 0) {\n      return GESTURES.SWIPE_LEFT;\n    } else {\n      return GESTURES.SWIPE_RIGHT;\n    }\n  } else if (distanceY > distanceX && distanceY > swipeThreshold) {\n    if (displacementY < 0) {\n      return GESTURES.SWIPE_UP;\n    } else {\n      return GESTURES.SWIPE_DOWN;\n    }\n  }\n  return GESTURES.SINGLE_TAP;\n}\n","import Phaser from 'phaser';\nimport {\n  initSettings,\n  getDimensions,\n  getGamemodeInfo\n} from '../Game/gameSettings';\nimport { BLACK, GOLD, GRAY, WHITE } from '../Common/colours';\nimport { GESTURES, gestureDetection } from '../Game/gestures';\n\nexport default class MainMenu extends Phaser.Scene {\n  constructor() {\n    super('MainMenu');\n  }\n\n  init(data) {\n    this.settings = { ...initSettings(), ...data };\n    this.handleGesture = this.handleGesture.bind(this);\n  }\n\n  preload() {\n    this.load.setBaseURL(\n      'https://raw.githubusercontent.com/wjxhenry/website/master'\n    );\n    // Load assets...\n  }\n\n  create() {\n    this.cameras.main.setBackgroundColor(WHITE);\n    this.keys = this.input.keyboard.addKeys({\n      up: 'W',\n      arrowUp: 'up',\n      down: 'S',\n      arrowDown: 'down',\n      select: 'Enter'\n    });\n    gestureDetection(this.input, this.handleGesture);\n\n    this.gameDimensions = getDimensions(this.game);\n\n    this.choice = 0;\n\n    this.doubleTapTimer = 0;\n    this.doubleTapCooldown = 200; // 200 milliseconds between each tap\n\n    let title = this.add.text(\n      this.gameDimensions.screenCenter,\n      this.gameDimensions.screenSpaceUnit * 4,\n      'Yet Another Maze',\n      {\n        fontFamily: 'Ubuntu',\n        fill: BLACK,\n        fontSize: this.gameDimensions.textSize2\n      }\n    );\n    title.setOrigin(0.5, 0.5);\n    let startGame = this.add.text(\n      this.gameDimensions.screenCenter,\n      this.gameDimensions.screenSpaceUnit * 8,\n      'Start Game',\n      {\n        fontFamily: 'Ubuntu',\n        fill: GOLD,\n        fontSize: this.gameDimensions.textSize3\n      }\n    );\n    startGame.setOrigin(0.5, 0.5);\n    let settings = this.add.text(\n      this.gameDimensions.screenCenter,\n      this.gameDimensions.screenSpaceUnit * 12,\n      'Settings',\n      {\n        fontFamily: 'Ubuntu',\n        fill: BLACK,\n        fontSize: this.gameDimensions.textSize3\n      }\n    );\n    settings.setOrigin(0.5, 0.5);\n    let exit = this.add.text(\n      this.gameDimensions.screenCenter,\n      this.gameDimensions.screenSpaceUnit * 16,\n      'Exit',\n      {\n        fontFamily: 'Ubuntu',\n        fill: GRAY,\n        fontSize: this.gameDimensions.textSize3\n      }\n    );\n    exit.setOrigin(0.5, 0.5);\n\n    this.options = [\n      { text: startGame, scene: getGamemodeInfo(this.settings.gameMode).scene },\n      { text: settings, scene: 'Settings' }\n      // { text: exit, scene: 'Null' }\n    ];\n  }\n\n  handleGesture(detection) {\n    if (detection.gesture === GESTURES.SWIPE_UP) {\n      this.updateChoice(-1);\n    } else if (detection.gesture === GESTURES.SWIPE_DOWN) {\n      this.updateChoice(1);\n    } else if (detection.gesture === GESTURES.SINGLE_TAP) {\n      if (new Date().getTime() - this.doubleTapTimer < this.doubleTapCooldown) {\n        this.scene.start(this.options[this.choice].scene, this.settings);\n      }\n      this.doubleTapTimer = new Date().getTime();\n    }\n  }\n\n  update() {\n    if (\n      Phaser.Input.Keyboard.JustDown(this.keys.up) ||\n      Phaser.Input.Keyboard.JustDown(this.keys.arrowUp)\n    ) {\n      this.updateChoice(-1);\n    }\n    if (\n      Phaser.Input.Keyboard.JustDown(this.keys.down) ||\n      Phaser.Input.Keyboard.JustDown(this.keys.arrowDown)\n    ) {\n      this.updateChoice(1);\n    }\n    if (Phaser.Input.Keyboard.JustDown(this.keys.select)) {\n      this.scene.start(this.options[this.choice].scene, this.settings);\n    }\n  }\n\n  updateChoice(direction) {\n    let newChoice = this.choice + direction;\n    if (newChoice > -1 && newChoice < this.options.length) {\n      this.options[this.choice].text.setFill(BLACK);\n      this.options[newChoice].text.setFill(GOLD);\n      this.choice = newChoice;\n    }\n  }\n}\n","import Phaser from 'phaser';\nimport { getDimensions } from '../Game/gameSettings';\nimport { BLACK, GOLD, GRAY, WHITE } from '../Common/colours';\nimport { GAMEMODES, getGamemodeInfo } from '../Game/gameSettings';\nimport { GESTURES, gestureDetection } from '../Game/gestures';\n\nexport default class Settings extends Phaser.Scene {\n  constructor() {\n    super('Settings');\n  }\n\n  init(data) {\n    this.settings = data;\n    this.handleGesture = this.handleGesture.bind(this);\n  }\n\n  preload() {\n    this.load.setBaseURL(\n      'https://raw.githubusercontent.com/wjxhenry/website/master'\n    );\n    // Load assets...\n  }\n\n  create() {\n    this.cameras.main.setBackgroundColor(WHITE);\n    this.keys = this.input.keyboard.addKeys({\n      up: 'W',\n      arrowUp: 'up',\n      down: 'S',\n      arrowDown: 'down',\n      left: 'A',\n      arrowLeft: 'left',\n      right: 'D',\n      arrowRight: 'right',\n      select: 'Enter'\n    });\n    gestureDetection(this.input, this.handleGesture);\n\n    this.gameDimensions = getDimensions(this.game);\n\n    this.choice = 0;\n\n    this.doubleTapTimer = 0;\n    this.doubleTapCooldown = 200; // 200 milliseconds between each tap\n\n    let title = this.add.text(\n      this.gameDimensions.screenCenter,\n      this.gameDimensions.screenSpaceUnit * 4,\n      'Settings',\n      {\n        fontFamily: 'Ubuntu',\n        fill: BLACK,\n        fontSize: this.gameDimensions.textSize1\n      }\n    );\n    title.setOrigin(0.5, 0.5);\n    let gridSize = this.add.text(\n      this.gameDimensions.screenCenter,\n      this.gameDimensions.screenSpaceUnit * 8,\n      `Grid size: ${this.settings.gridSize}`,\n      {\n        fontFamily: 'Ubuntu',\n        fill: GOLD,\n        fontSize: this.gameDimensions.textSize3\n      }\n    );\n    gridSize.setOrigin(0.5, 0.5);\n    let sideLength = this.add.text(\n      this.gameDimensions.screenCenter,\n      this.gameDimensions.screenSpaceUnit * 11,\n      `Side length: ${this.settings.sideLength}`,\n      {\n        fontFamily: 'Ubuntu',\n        fill: GRAY,\n        fontSize: this.gameDimensions.textSize3\n      }\n    );\n    sideLength.setOrigin(0.5, 0.5);\n    let gameMode = this.add.text(\n      this.gameDimensions.screenCenter,\n      this.gameDimensions.screenSpaceUnit * 14,\n      getGamemodeInfo(this.settings.gameMode).text,\n      {\n        fontFamily: 'Ubuntu',\n        fill: BLACK,\n        fontSize: this.gameDimensions.textSize3\n      }\n    );\n    gameMode.setOrigin(0.5, 0.5);\n    let menuReturn = this.add.text(\n      this.gameDimensions.screenCenter,\n      this.gameDimensions.screenSpaceUnit * 17,\n      'Return',\n      {\n        fontFamily: 'Ubuntu',\n        fill: BLACK,\n        fontSize: this.gameDimensions.textSize3\n      }\n    );\n    menuReturn.setOrigin(0.5, 0.5);\n\n    this.options = [gridSize, gameMode, menuReturn];\n  }\n\n  handleGesture(detection) {\n    if (detection.gesture === GESTURES.SWIPE_UP) {\n      this.updateChoice(-1);\n    } else if (detection.gesture === GESTURES.SWIPE_DOWN) {\n      this.updateChoice(1);\n    } else if (detection.gesture === GESTURES.SWIPE_RIGHT) {\n      this.updateSelection(1);\n    } else if (detection.gesture === GESTURES.SWIPE_LEFT) {\n      this.updateSelection(-1);\n    } else if (detection.gesture === GESTURES.SINGLE_TAP) {\n      if (new Date().getTime() - this.doubleTapTimer < this.doubleTapCooldown) {\n        if (this.choice === 2) {\n          this.scene.start('MainMenu', this.settings);\n        }\n      }\n      this.doubleTapTimer = new Date().getTime();\n    }\n  }\n\n  update() {\n    if (\n      Phaser.Input.Keyboard.JustDown(this.keys.up) ||\n      Phaser.Input.Keyboard.JustDown(this.keys.arrowUp)\n    ) {\n      this.updateChoice(-1);\n    }\n    if (\n      Phaser.Input.Keyboard.JustDown(this.keys.down) ||\n      Phaser.Input.Keyboard.JustDown(this.keys.arrowDown)\n    ) {\n      this.updateChoice(1);\n    }\n    if (\n      Phaser.Input.Keyboard.JustDown(this.keys.right) ||\n      Phaser.Input.Keyboard.JustDown(this.keys.arrowRight)\n    ) {\n      this.updateSelection(1);\n    }\n    if (\n      Phaser.Input.Keyboard.JustDown(this.keys.left) ||\n      Phaser.Input.Keyboard.JustDown(this.keys.arrowLeft)\n    ) {\n      this.updateSelection(-1);\n    }\n    if (Phaser.Input.Keyboard.JustDown(this.keys.select)) {\n      if (this.choice === 2) {\n        this.scene.start('MainMenu', this.settings);\n      }\n    }\n  }\n\n  updateChoice(direction) {\n    let newChoice = this.choice + direction;\n    if (newChoice > -1 && newChoice < this.options.length) {\n      this.options[this.choice].setFill(BLACK);\n      this.options[newChoice].setFill(GOLD);\n      this.choice = newChoice;\n    }\n  }\n\n  updateSelection(direction) {\n    if (this.choice === 0) {\n      this.updateGridSize(direction);\n    } else if (this.choice === 1) {\n      this.updateGameMode(direction);\n    }\n    // else if (this.choice === 1) {\n    //   this.updateSideLength(direction);\n    // }\n  }\n\n  updateGridSize(direction) {\n    let newGridSize = this.settings.gridSize + direction;\n    if (\n      newGridSize > this.settings.minGridSize - 1 &&\n      newGridSize < this.settings.maxGridSize + 1\n    ) {\n      this.options[0].setText(`Grid size: ${newGridSize}`);\n      this.settings.gridSize = newGridSize;\n    }\n  }\n\n  updateSideLength(direction) {\n    let newSideLength = this.settings.sideLength + direction;\n    if (\n      newSideLength > this.settings.minSideLength - 1 &&\n      newSideLength < this.settings.maxSideLength + 1\n    ) {\n      this.options[1].setText(`Side length: ${newSideLength}`);\n      this.settings.sideLength = newSideLength;\n    }\n  }\n\n  updateGameMode(direction) {\n    let newGameMode = this.settings.gameMode + direction;\n    if (newGameMode > -1 && newGameMode < Object.keys(GAMEMODES).length) {\n      this.options[1].setText(getGamemodeInfo(newGameMode).text);\n      this.settings.gameMode = newGameMode;\n    }\n  }\n}\n","/**\n * Directed Graph Class\n *\n * This graph class is a container that holds a set\n * of vertices and a list of directed edges.\n * Edges are modelled as tuples (u,v) of vertices.\n *\n * Uses an adjacency list representation. Loops\n * and parallel copies of edges can be stored.\n */\n\nexport default class Graph {\n  constructor(vertices = new Set(), edges = []) {\n    this.alist = {};\n\n    vertices.forEach(v => {\n      this.addVertex(v);\n    });\n    edges.forEach(e => {\n      this.addEdge(e);\n    });\n  }\n\n  getVertices() {\n    return new Set(Object.keys(this.alist));\n  }\n\n  getEdges() {\n    let edges = [];\n    Object.keys(this.alist).forEach(key => {\n      this.alist[key].forEach(vertex => {\n        if (Number.isInteger(vertex)) {\n          edges.push([Number(key), vertex]);\n        } else {\n          edges.push([key, vertex]);\n        }\n      });\n    });\n    return edges;\n  }\n\n  addVertex(v) {\n    if (!(v in this.alist)) {\n      this.alist[v] = new Set();\n    }\n  }\n\n  addEdge(e) {\n    if (!this.isVertex(e[0]) || !this.isVertex(e[1])) {\n      throw new Error('An endpoint is not in graph');\n    }\n    this.alist[e[0]].add(e[1]);\n  }\n\n  isVertex(v) {\n    return v in this.alist;\n  }\n\n  isEdge(e) {\n    if (!(e[0] in this.alist)) {\n      return false;\n    }\n    return this.alist[e[0]].has(e[1]);\n  }\n\n  neighbours(v) {\n    if (!this.isVertex(v)) {\n      throw new Error('Vertex not in graph');\n    }\n    return Array.from(this.alist[v]);\n  }\n\n  static isWalk(g, walk) {\n    if (walk.length === 0)\n      // Should have at least one vertex\n      return false;\n\n    if (walk.length === 1) return g.isVertex(walk[0]);\n\n    for (let i = 0; i < walk.length - 1; i++) {\n      if (!g.isEdge([walk[i], walk[i + 1]])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  static isPath(g, path) {\n    if (new Set(path).size < path.length) return false;\n\n    return this.isWalk(g, path);\n  }\n}\n","import Maze from '../Utils/maze';\nimport { getDimensions } from './gameSettings';\nimport { WHITE_0x } from '../Common/colours';\n\nexport default class GameMaze extends Maze {\n  /**\n   * Constructor\n   * @param {Phaser.Game} game - The Phaser game object\n   * @param {Phaser.GameObjects.Graphics} graphics - The Phaser graphics object\n   * @param {Number} size - The size of the maze (size x size grid)\n   * @param {Number} colour - The hexadecimal colour to fill in the maze (colour of the paths)\n   */\n  constructor(game, graphics, size, colour = WHITE_0x) {\n    super(size);\n    this.size = size;\n    this.game = game;\n    this.graphics = graphics;\n    this.graphics.setPosition(1, 1); // The border for the maze is 1\n    this.gameDimensions = getDimensions(this.game);\n    this.sideLength = (this.gameDimensions.screenLength - 2) / size;\n    this.colour = colour;\n  }\n\n  /**\n   * Draws the maze\n   */\n  drawMaze() {\n    this.graphics.fillStyle(this.colour);\n    this.maze.getVertices().forEach(vertex => {\n      let pos = vertex.split(',');\n      // Vertex\n      let vertX = Number(pos[0]);\n      let vertY = Number(pos[1]);\n      // Grid unit\n      let rectX = vertX * this.sideLength + 1;\n      let rectY = vertY * this.sideLength + 1;\n      let lengthX = this.sideLength - 2;\n      let lengthY = this.sideLength - 2;\n      // Update the grid unit dimensions\n      if (this.maze.isEdge([vertex, `${vertX - 1},${vertY}`])) {\n        rectX -= 1;\n        lengthX += 1;\n      }\n      if (this.maze.isEdge([vertex, `${vertX + 1},${vertY}`])) {\n        lengthX += 1;\n      }\n      if (this.maze.isEdge([vertex, `${vertX},${vertY - 1}`])) {\n        rectY -= 1;\n        lengthY += 1;\n      }\n      if (this.maze.isEdge([vertex, `${vertX},${vertY + 1}`])) {\n        lengthY += 1;\n      }\n      // Draw the grid unit\n      this.graphics.fillRect(rectX, rectY, lengthX, lengthY);\n    });\n  }\n\n  /**\n   * Fill the grid with colour at the specified position\n   * @param {Object} position\n   * @param {Number} position.x - The x coordinate of the vertex to fill\n   * @param {Number} position.y - The y coordinate of the vertex to fill\n   * @param {Number} colour - Hexadecimal colour of the grid\n   */\n  fillGrid(position, colour) {\n    this.graphics.fillStyle(colour);\n    this.graphics.fillRect(\n      position.x * this.sideLength + 1,\n      position.y * this.sideLength + 1,\n      this.sideLength - 2,\n      this.sideLength - 2\n    );\n  }\n}\n","import Graph from './graph';\nimport { shuffle } from '../Common/shuffle';\n\nexport default class Maze {\n  constructor(size = 0) {\n    this.maze = this._createGrid(size);\n    this._createMaze(`${Math.floor(size / 2)},${Math.floor(size / 2)}`);\n  }\n\n  getVertices() {\n    return this.maze.getVertices();\n  }\n\n  isEdge(e) {\n    return this.maze.isEdge(e);\n  }\n\n  _createGrid(size) {\n    let grid = new Graph();\n    for (let i = 0; i < size; i++) {\n      for (let j = 0; j < size; j++) {\n        grid.addVertex(`${i},${j}`);\n      }\n    }\n    return grid;\n  }\n\n  _createMaze(vertex, completed = null, vertices = null) {\n    if (vertices == null) {\n      vertices = this.getVertices();\n    }\n    if (completed == null) {\n      completed = new Set(vertex);\n    }\n\n    let paths = shuffle(['up', 'down', 'left', 'right']);\n\n    let coords = vertex.split(',').map(position => {\n      return parseInt(position);\n    });\n\n    let up = `${coords[0]},${coords[1] - 1}`;\n    let down = `${coords[0]},${coords[1] + 1}`;\n    let left = `${coords[0] - 1},${coords[1]}`;\n    let right = `${coords[0] + 1},${coords[1]}`;\n\n    paths.forEach(direction => {\n      if (direction === 'up') {\n        if (vertices.has(up) && !completed.has(up)) {\n          this.maze.addEdge([vertex, up]);\n          this.maze.addEdge([up, vertex]);\n          completed.add(up);\n          this._createMaze(up, completed, vertices);\n        }\n      } else if (direction === 'down') {\n        if (vertices.has(down) && !completed.has(down)) {\n          this.maze.addEdge([vertex, down]);\n          this.maze.addEdge([down, vertex]);\n          completed.add(down);\n          this._createMaze(down, completed, vertices);\n        }\n      } else if (direction === 'left') {\n        if (vertices.has(left) && !completed.has(left)) {\n          this.maze.addEdge([vertex, left]);\n          this.maze.addEdge([left, vertex]);\n          completed.add(left);\n          this._createMaze(left, completed, vertices);\n        }\n      } else if (direction === 'right') {\n        if (vertices.has(right) && !completed.has(right)) {\n          this.maze.addEdge([vertex, right]);\n          this.maze.addEdge([right, vertex]);\n          completed.add(right);\n          this._createMaze(right, completed, vertices);\n        }\n      }\n    });\n  }\n}\n","import { GOLD_0x } from '../Common/colours';\n\n/**\n * @typedef {Object} Position - The x and y coordinates\n * @property {Number} x - The x coordinate\n * @property {Number} y - The y coordinate\n */\n\n/**\n * @typedef {Object} Direction\n * @property {Number} UP - Up\n * @property {Number} DOWN - Down\n * @property {Number} LEFT - Left\n * @property {Number} RIGHT - Right\n */\n\nconst DIRECTIONS = {\n  UP: 0,\n  DOWN: 1,\n  LEFT: 2,\n  RIGHT: 3\n};\n\n/**\n * The default number of intermediate steps (frames) between character movement\n */\nconst DEFAULT_UPDATE_STEPS = 5;\n\nexport default class Character {\n  /**\n   * Constructor\n   * @param {GameMaze} maze - An instance of the GameMaze object\n   * @param {Object} position - The initial position of the character\n   * @param {Number} position.x - The x coordinate of the character\n   * @param {Number} position.y - The y coordinate of the character\n   * @param {Object} [options]\n   * @param {String} [options.colour] - The hexadecimal colour of the character (defaults to gold)\n   * @param {Number} [options.updateSteps] - The number of intermediate steps (frames) between character movement (default: 5)\n   * @param {Boolean} [options.smoothMovement] - The flag to allow for smooth movement (default: false)\n   */\n  constructor(maze, position, options = {}) {\n    this.maze = maze;\n    this.position = position;\n    this.prevPos = position;\n    this.colour = options.colour || GOLD_0x;\n    this.smoothMovement = options.smoothMovement || false;\n    this.UPDATE_STEPS = options.updateSteps || DEFAULT_UPDATE_STEPS;\n    this.updating = false;\n    this.updateStep = 0;\n  }\n\n  static get DIRECTIONS() {\n    return DIRECTIONS;\n  }\n\n  /**\n   * Draw the character at its current position\n   */\n  drawCharacter() {\n    this.maze.fillGrid(this.position, this.colour);\n  }\n\n  /**\n   * Moves the character in the specified direction if possible\n   * @param {Direction} direction - The direction to move\n   */\n  moveCharacter(direction) {\n    // If the chracter is currently updating, ignore the move command\n    if (this.updating) {\n      return;\n    }\n    // Return the current character position\n    let prevPos = { ...this.position };\n    let newPos = { ...this.position };\n    if (direction === DIRECTIONS.UP) {\n      newPos.y -= 1;\n      if (newPos.y < 0) {\n        newPos.y = 0;\n      }\n    } else if (direction === DIRECTIONS.DOWN) {\n      newPos.y += 1;\n      if (newPos.y > this.maze.size - 1) {\n        newPos.y = this.maze.size - 1;\n      }\n    } else if (direction === DIRECTIONS.LEFT) {\n      newPos.x -= 1;\n      if (newPos.x < 0) {\n        newPos.x = 0;\n      }\n    } else if (direction === DIRECTIONS.RIGHT) {\n      newPos.x += 1;\n      if (newPos.x > this.maze.size - 1) {\n        newPos.x = this.maze.size - 1;\n      }\n    }\n    if (\n      this.maze.isEdge([`${prevPos.x},${prevPos.y}`, `${newPos.x},${newPos.y}`])\n    ) {\n      // Update the positions\n      this.position = newPos;\n      this.prevPos = prevPos;\n      if (this.smoothMovement) {\n        // Set the flag to update the player movement\n        this.updating = true;\n      } else {\n        this.maze.fillGrid(this.prevPos, this.maze.colour);\n        this.maze.fillGrid(this.position, this.colour);\n      }\n    }\n  }\n\n  /**\n   * This function should always be called in the Scene's update function\n   */\n  update() {\n    if (this.updating) {\n      this._smoothMovement(this.prevPos, this.position);\n    }\n  }\n\n  /**\n   * Returns whether or not the character is updating\n   * @returns {Boolean}\n   */\n  isUpdating() {\n    return this.updating;\n  }\n\n  /**\n   * This function is called internally to draw the intermediate steps of the character movement\n   */\n  _smoothMovement() {\n    let diffX = Math.round(this.position.x - this.prevPos.x);\n    let diffY = Math.round(this.position.y - this.prevPos.y);\n    if (diffX !== 0) {\n      // Calculating the intermediate steps...\n      let interFrom = {\n        ...this.prevPos,\n        x:\n          Math.round(\n            (this.prevPos.x +\n              (1 / this.UPDATE_STEPS) * this.updateStep * diffX) *\n              10\n          ) / 10\n      };\n      let interTo = {\n        ...this.prevPos,\n        x:\n          Math.round(\n            (this.prevPos.x +\n              (1 / this.UPDATE_STEPS) * (this.updateStep + 1) * diffX) *\n              10\n          ) / 10\n      };\n      this.maze.fillGrid(interFrom, this.maze.colour);\n      this.maze.fillGrid(interTo, this.colour);\n    } else {\n      let interFrom = {\n        ...this.prevPos,\n        y:\n          Math.round(\n            (this.prevPos.y +\n              (1 / this.UPDATE_STEPS) * this.updateStep * diffY) *\n              10\n          ) / 10\n      };\n      let interTo = {\n        ...this.prevPos,\n        y:\n          Math.round(\n            (this.prevPos.y +\n              (1 / this.UPDATE_STEPS) * (this.updateStep + 1) * diffY) *\n              10\n          ) / 10\n      };\n      this.maze.fillGrid(interFrom, this.maze.colour);\n      this.maze.fillGrid(interTo, this.colour);\n    }\n\n    this.updateStep++;\n    if (this.updateStep % this.UPDATE_STEPS === 0) {\n      this.updateStep = 0;\n      this.updating = false;\n    }\n  }\n}\n","import Phaser from 'phaser';\nimport { BLACK_0x, GRAY_0x, BLACK } from '../Common/colours';\nimport GameMaze from '../Game/gameMaze';\nimport Character from '../Game/character';\nimport { GESTURES, gestureDetection } from '../Game/gestures';\nimport { GAMEMODES } from '../Game/gameSettings';\n\nexport default class GamemodeSolo extends Phaser.Scene {\n  constructor() {\n    super('GamemodeSolo');\n  }\n\n  init(data) {\n    this.settings = data;\n    this.handleGesture = this.handleGesture.bind(this);\n    this.actionClock = 0;\n    this.actionCooldown = 100; // Time in milliseconds\n  }\n\n  preload() {\n    // Load assets...\n  }\n\n  create() {\n    this.cameras.main.setBackgroundColor(BLACK_0x);\n    this.keys = this.input.keyboard.addKeys({\n      up: 'W',\n      arrowUp: 'up',\n      down: 'S',\n      arrowDown: 'down',\n      left: 'A',\n      arrowLeft: 'left',\n      right: 'D',\n      arrowRight: 'right',\n      exit: 'Esc'\n    });\n    gestureDetection(this.input, this.handleGesture);\n\n    this.graphics = this.add.graphics();\n\n    this.maze = new GameMaze(this.game, this.graphics, this.settings.gridSize);\n\n    let initialPosition = {\n      x: 0,\n      y: 0\n    };\n    this.character = new Character(this.maze, initialPosition, {\n      smoothMovement: true\n    });\n\n    this.endPoint = {\n      x: this.settings.gridSize - 1,\n      y: this.settings.gridSize - 1\n    };\n\n    this.maze.drawMaze();\n\n    // Draw the endpoint\n    this.maze.fillGrid(this.endPoint, GRAY_0x);\n\n    // Draw the player\n    this.character.drawCharacter();\n\n    this.timer = new Date().getTime();\n  }\n\n  handleGesture(detection) {\n    if (detection.gesture === GESTURES.SWIPE_LEFT) {\n      this.updateMovement(Character.DIRECTIONS.LEFT);\n    } else if (detection.gesture === GESTURES.SWIPE_RIGHT) {\n      this.updateMovement(Character.DIRECTIONS.RIGHT);\n    } else if (detection.gesture === GESTURES.SWIPE_UP) {\n      this.updateMovement(Character.DIRECTIONS.UP);\n    } else if (detection.gesture === GESTURES.SWIPE_DOWN) {\n      this.updateMovement(Character.DIRECTIONS.DOWN);\n    }\n  }\n\n  updateMovement(direction) {\n    // Move the character\n    this.character.moveCharacter(direction);\n    // Check if player is in the finish position, if yes, finish game\n    if (\n      this.character.position.x === this.endPoint.x &&\n      this.character.position.y === this.endPoint.y\n    ) {\n      let finishTime = Math.floor((new Date().getTime() - this.timer) / 1000);\n      this.scene.start('EndScreen', {\n        settings: this.settings,\n        results: {\n          gameMode: GAMEMODES.SOLO.id,\n          message: `Time: ${finishTime} s`,\n          messageColour: BLACK\n        }\n      });\n    }\n  }\n\n  update() {\n    if (Phaser.Input.Keyboard.JustDown(this.keys.exit)) {\n      this.scene.start('MainMenu', this.settings);\n    }\n\n    if (new Date().getTime() - this.actionClock > this.actionCooldown) {\n      if (this.keys.up.isDown || this.keys.arrowUp.isDown) {\n        this.updateMovement(Character.DIRECTIONS.UP);\n        this.actionClock = new Date().getTime();\n      } else if (this.keys.down.isDown || this.keys.arrowDown.isDown) {\n        this.updateMovement(Character.DIRECTIONS.DOWN);\n        this.actionClock = new Date().getTime();\n      } else if (this.keys.left.isDown || this.keys.arrowLeft.isDown) {\n        this.updateMovement(Character.DIRECTIONS.LEFT);\n        this.actionClock = new Date().getTime();\n      } else if (this.keys.right.isDown || this.keys.arrowRight.isDown) {\n        this.updateMovement(Character.DIRECTIONS.RIGHT);\n        this.actionClock = new Date().getTime();\n      }\n    }\n\n    this.character.update();\n  }\n}\n","import Phaser from 'phaser';\nimport { BLACK_0x, BLUE_0x, GREEN_0x, BLUE, GREEN } from '../Common/colours';\nimport GameMaze from '../Game/gameMaze';\nimport Character from '../Game/character';\nimport { GESTURES, gestureDetection } from '../Game/gestures';\nimport { GAMEMODES } from '../Game/gameSettings';\n\nexport default class GamemodeTwoPlayer extends Phaser.Scene {\n  constructor() {\n    super('GamemodeTwoPlayer');\n  }\n\n  init(data) {\n    this.settings = data;\n    this.handleGesture = this.handleGesture.bind(this);\n    this.p1ActionClock = 0;\n    this.p2ActionClock = 0;\n    this.actionCooldown = 100; // Time in milliseconds\n  }\n\n  preload() {\n    // Load assets...\n  }\n\n  create() {\n    this.cameras.main.setBackgroundColor(BLACK_0x);\n    this.keys = this.input.keyboard.addKeys({\n      p1Up: 'up',\n      p2Up: 'W',\n      p1Down: 'down',\n      p2Down: 'S',\n      p1Left: 'left',\n      p2Left: 'A',\n      p1Right: 'right',\n      p2Right: 'D',\n      exit: 'Esc'\n    });\n    this.screenHalfway = this.game.config.width / 2;\n    gestureDetection(this.input, this.handleGesture);\n\n    this.graphics = this.add.graphics();\n\n    this.maze = new GameMaze(this.game, this.graphics, this.settings.gridSize);\n\n    let positions = this.generateRandomPositions();\n\n    let p1InitialPosition = positions.p1;\n    let p2InitialPosition = positions.p2;\n    this.p1EndPoint = positions.p2;\n    this.p2EndPoint = positions.p1;\n\n    this.player1 = new Character(this.maze, p1InitialPosition, {\n      smoothMovement: true,\n      colour: BLUE_0x\n    });\n    this.player2 = new Character(this.maze, p2InitialPosition, {\n      smoothMovement: true,\n      colour: GREEN_0x\n    });\n\n    this.maze.drawMaze();\n\n    // Draw the players\n    this.player1.drawCharacter();\n    this.player2.drawCharacter();\n\n    this.timer = new Date().getTime();\n  }\n\n  generateRandomPositions() {\n    let furthestPoint = this.settings.gridSize - 1;\n    let position1 = {\n      p1: {\n        x: 0,\n        y: 0\n      },\n      p2: {\n        x: furthestPoint,\n        y: furthestPoint\n      }\n    };\n    let position2 = {\n      p1: {\n        x: furthestPoint,\n        y: 0\n      },\n      p2: {\n        x: 0,\n        y: furthestPoint\n      }\n    };\n    let position3 = {\n      p1: {\n        x: 0,\n        y: furthestPoint\n      },\n      p2: {\n        x: furthestPoint,\n        y: 0\n      }\n    };\n    let position4 = {\n      p1: {\n        x: furthestPoint,\n        y: furthestPoint\n      },\n      p2: {\n        x: 0,\n        y: 0\n      }\n    };\n    let positions = [position1, position2, position3, position4];\n    return positions[Math.floor(Math.random() * 4)];\n  }\n\n  handleGesture(detection) {\n    if (detection.gesture === GESTURES.SWIPE_LEFT) {\n      if (detection.origin.y > this.screenHalfway) {\n        this.p1UpdateMovement(Character.DIRECTIONS.LEFT);\n      } else {\n        this.p2UpdateMovement(Character.DIRECTIONS.LEFT);\n      }\n    } else if (detection.gesture === GESTURES.SWIPE_RIGHT) {\n      if (detection.origin.y > this.screenHalfway) {\n        this.p1UpdateMovement(Character.DIRECTIONS.RIGHT);\n      } else {\n        this.p2UpdateMovement(Character.DIRECTIONS.RIGHT);\n      }\n    } else if (detection.gesture === GESTURES.SWIPE_UP) {\n      if (detection.origin.y > this.screenHalfway) {\n        this.p1UpdateMovement(Character.DIRECTIONS.UP);\n      } else {\n        this.p2UpdateMovement(Character.DIRECTIONS.UP);\n      }\n    } else if (detection.gesture === GESTURES.SWIPE_DOWN) {\n      if (detection.origin.y > this.screenHalfway) {\n        this.p1UpdateMovement(Character.DIRECTIONS.DOWN);\n      } else {\n        this.p2UpdateMovement(Character.DIRECTIONS.DOWN);\n      }\n    }\n  }\n\n  p1UpdateMovement(direction) {\n    // Move the character\n    this.player1.moveCharacter(direction);\n    // Check if player is in the finish position, if yes, finish game\n    if (\n      this.player1.position.x === this.p1EndPoint.x &&\n      this.player1.position.y === this.p1EndPoint.y\n    ) {\n      this.scene.start('EndScreen', {\n        settings: this.settings,\n        results: {\n          gameMode: GAMEMODES.TWO_PLAYER.id,\n          message: 'Player 1 wins!',\n          messageColour: BLUE\n        }\n      });\n    }\n  }\n\n  p2UpdateMovement(direction) {\n    // Move the character\n    this.player2.moveCharacter(direction);\n    // Check if player is in the finish position, if yes, finish game\n    if (\n      this.player2.position.x === this.p2EndPoint.x &&\n      this.player2.position.y === this.p2EndPoint.y\n    ) {\n      this.scene.start('EndScreen', {\n        settings: this.settings,\n        results: {\n          gameMode: GAMEMODES.TWO_PLAYER.id,\n          message: 'Player 2 wins!',\n          messageColour: GREEN\n        }\n      });\n    }\n  }\n\n  update() {\n    if (Phaser.Input.Keyboard.JustDown(this.keys.exit)) {\n      this.scene.start('MainMenu', this.settings);\n    }\n\n    let dateNow = new Date().getTime();\n\n    if (dateNow - this.p1ActionClock > this.actionCooldown) {\n      if (this.keys.p1Up.isDown) {\n        this.p1UpdateMovement(Character.DIRECTIONS.UP);\n        this.p1ActionClock = new Date().getTime();\n      } else if (this.keys.p1Down.isDown) {\n        this.p1UpdateMovement(Character.DIRECTIONS.DOWN);\n        this.p1ActionClock = new Date().getTime();\n      } else if (this.keys.p1Left.isDown) {\n        this.p1UpdateMovement(Character.DIRECTIONS.LEFT);\n        this.p1ActionClock = new Date().getTime();\n      } else if (this.keys.p1Right.isDown) {\n        this.p1UpdateMovement(Character.DIRECTIONS.RIGHT);\n        this.p1ActionClock = new Date().getTime();\n      }\n    }\n\n    if (dateNow - this.p2ActionClock > this.actionCooldown) {\n      if (this.keys.p2Up.isDown) {\n        this.p2UpdateMovement(Character.DIRECTIONS.UP);\n        this.p2ActionClock = new Date().getTime();\n      } else if (this.keys.p2Down.isDown) {\n        this.p2UpdateMovement(Character.DIRECTIONS.DOWN);\n        this.p2ActionClock = new Date().getTime();\n      } else if (this.keys.p2Left.isDown) {\n        this.p2UpdateMovement(Character.DIRECTIONS.LEFT);\n        this.p2ActionClock = new Date().getTime();\n      } else if (this.keys.p2Right.isDown) {\n        this.p2UpdateMovement(Character.DIRECTIONS.RIGHT);\n        this.p2ActionClock = new Date().getTime();\n      }\n    }\n\n    this.player1.update();\n    this.player2.update();\n    if (!this.player1.isUpdating()) {\n      // Redraw the endpoints in case players moved over them\n      this.maze.fillGrid(this.p2EndPoint, GREEN_0x);\n      this.player1.drawCharacter();\n    }\n    if (!this.player2.isUpdating()) {\n      this.maze.fillGrid(this.p1EndPoint, BLUE_0x);\n      this.player2.drawCharacter();\n    }\n  }\n}\n","import Phaser from 'phaser';\nimport { getDimensions } from '../Game/gameSettings';\nimport { BLACK, WHITE } from '../Common/colours';\nimport { GESTURES, gestureDetection } from '../Game/gestures';\n\nexport default class GamemodeRace extends Phaser.Scene {\n  constructor() {\n    super('GamemodeRace');\n  }\n\n  init(data) {\n    this.settings = data.settings;\n    this.handleGesture = this.handleGesture.bind(this);\n  }\n\n  create() {\n    this.cameras.main.setBackgroundColor(WHITE);\n    this.keys = this.input.keyboard.addKeys({\n      continue: 'Enter'\n    });\n    gestureDetection(this.input, this.handleGesture);\n\n    this.gameDimensions = getDimensions(this.game);\n\n    this.drawScreen();\n  }\n\n  drawScreen() {\n    let toBeImplemented = this.add.text(\n      this.gameDimensions.screenCenter,\n      this.gameDimensions.screenSpaceUnit * 4,\n      'Race (WIP)',\n      {\n        fontFamily: 'Ubuntu',\n        fill: BLACK,\n        fontSize: this.gameDimensions.textSize1\n      }\n    );\n    toBeImplemented.setOrigin(0.5, 0.5);\n  }\n\n  handleGesture(detection) {\n    if (detection.gesture === GESTURES.SINGLE_TAP) {\n      this.scene.start('MainMenu', this.settings);\n    }\n  }\n\n  update() {\n    if (Phaser.Input.Keyboard.JustDown(this.keys.continue)) {\n      this.scene.start('MainMenu', this.settings);\n    }\n  }\n}\n","import Phaser from 'phaser';\nimport { getDimensions } from '../Game/gameSettings';\nimport { BLACK, WHITE } from '../Common/colours';\nimport { GESTURES, gestureDetection } from '../Game/gestures';\n\nexport default class GamemodeChase extends Phaser.Scene {\n  constructor() {\n    super('GamemodeChase');\n  }\n\n  init(data) {\n    this.settings = data.settings;\n    this.handleGesture = this.handleGesture.bind(this);\n  }\n\n  create() {\n    this.cameras.main.setBackgroundColor(WHITE);\n    this.keys = this.input.keyboard.addKeys({\n      continue: 'Enter'\n    });\n    gestureDetection(this.input, this.handleGesture);\n\n    this.gameDimensions = getDimensions(this.game);\n\n    this.drawScreen();\n  }\n\n  drawScreen() {\n    let toBeImplemented = this.add.text(\n      this.gameDimensions.screenCenter,\n      this.gameDimensions.screenSpaceUnit * 4,\n      'Chase (WIP)',\n      {\n        fontFamily: 'Ubuntu',\n        fill: BLACK,\n        fontSize: this.gameDimensions.textSize1\n      }\n    );\n    toBeImplemented.setOrigin(0.5, 0.5);\n  }\n\n  handleGesture(detection) {\n    if (detection.gesture === GESTURES.SINGLE_TAP) {\n      this.scene.start('MainMenu', this.settings);\n    }\n  }\n\n  update() {\n    if (Phaser.Input.Keyboard.JustDown(this.keys.continue)) {\n      this.scene.start('MainMenu', this.settings);\n    }\n  }\n}\n","import Phaser from 'phaser';\nimport { getDimensions } from '../Game/gameSettings';\nimport { BLACK, WHITE } from '../Common/colours';\nimport { GESTURES, gestureDetection } from '../Game/gestures';\n\nexport default class GamemodeEscape extends Phaser.Scene {\n  constructor() {\n    super('GamemodeEscape');\n  }\n\n  init(data) {\n    this.settings = data.settings;\n    this.handleGesture = this.handleGesture.bind(this);\n  }\n\n  create() {\n    this.cameras.main.setBackgroundColor(WHITE);\n    this.keys = this.input.keyboard.addKeys({\n      continue: 'Enter'\n    });\n    gestureDetection(this.input, this.handleGesture);\n\n    this.gameDimensions = getDimensions(this.game);\n\n    this.drawScreen();\n  }\n\n  drawScreen() {\n    let toBeImplemented = this.add.text(\n      this.gameDimensions.screenCenter,\n      this.gameDimensions.screenSpaceUnit * 4,\n      'Escape (WIP)',\n      {\n        fontFamily: 'Ubuntu',\n        fill: BLACK,\n        fontSize: this.gameDimensions.textSize1\n      }\n    );\n    toBeImplemented.setOrigin(0.5, 0.5);\n  }\n\n  handleGesture(detection) {\n    if (detection.gesture === GESTURES.SINGLE_TAP) {\n      this.scene.start('MainMenu', this.settings);\n    }\n  }\n\n  update() {\n    if (Phaser.Input.Keyboard.JustDown(this.keys.continue)) {\n      this.scene.start('MainMenu', this.settings);\n    }\n  }\n}\n","import Phaser from 'phaser';\nimport { getDimensions } from '../Game/gameSettings';\nimport { BLACK, WHITE } from '../Common/colours';\nimport { GESTURES, gestureDetection } from '../Game/gestures';\n\nexport default class EndScreen extends Phaser.Scene {\n  constructor() {\n    super('EndScreen');\n  }\n\n  init(data) {\n    this.settings = data.settings;\n    this.results = data.results;\n    this.handleGesture = this.handleGesture.bind(this);\n  }\n\n  create() {\n    this.cameras.main.setBackgroundColor(WHITE);\n    this.keys = this.input.keyboard.addKeys({\n      continue: 'Enter'\n    });\n    gestureDetection(this.input, this.handleGesture);\n\n    this.gameDimensions = getDimensions(this.game);\n\n    this.drawScreen();\n  }\n\n  drawScreen() {\n    let gameOver = this.add.text(\n      this.gameDimensions.screenCenter,\n      this.gameDimensions.screenSpaceUnit * 4,\n      'Game Over',\n      {\n        fontFamily: 'Ubuntu',\n        fill: BLACK,\n        fontSize: this.gameDimensions.textSize1\n      }\n    );\n    gameOver.setOrigin(0.5, 0.5);\n\n    let message = this.add.text(\n      this.gameDimensions.screenCenter,\n      this.gameDimensions.screenSpaceUnit * 9,\n      this.results.message,\n      {\n        fontFamily: 'Ubuntu',\n        fill: this.results.messageColour,\n        fontSize: this.gameDimensions.textSize2\n      }\n    );\n    message.setOrigin(0.5, 0.5);\n\n    let returnScreen = this.add.text(\n      this.gameDimensions.screenCenter,\n      this.gameDimensions.screenSpaceUnit * 15,\n      'Press enter to exit to menu.',\n      {\n        fontFamily: 'Ubuntu',\n        fill: BLACK,\n        fontSize: this.gameDimensions.textSize4\n      }\n    );\n    returnScreen.setOrigin(0.5, 0.5);\n  }\n\n  handleGesture(detection) {\n    if (detection.gesture === GESTURES.SINGLE_TAP) {\n      this.scene.start('MainMenu', this.settings);\n    }\n  }\n\n  update() {\n    if (Phaser.Input.Keyboard.JustDown(this.keys.continue)) {\n      this.scene.start('MainMenu', this.settings);\n    }\n  }\n}\n","import React from 'react';\nimport Phaser from 'phaser';\nimport MainMenu from './Scenes/MainMenu';\nimport Settings from './Scenes/Settings';\nimport GamemodeSolo from './Scenes/GamemodeSolo';\nimport GamemodeTwoPlayer from './Scenes/GamemodeTwoPlayer';\nimport GamemodeRace from './Scenes/GamemodeRace';\nimport GamemodeChase from './Scenes/GamemodeChase';\nimport GamemodeEscape from './Scenes/GamemodeEscape';\nimport EndScreen from './Scenes/EndScreen';\n\nexport default class Game extends React.Component {\n  componentDidMount() {\n    const dimension = this._getDimensions();\n    const config = {\n      type: Phaser.AUTO,\n      parent: 'phaser-parent',\n      pixelArt: true,\n      width: dimension * 0.8,\n      height: dimension * 0.8,\n      physics: {\n        default: 'arcade',\n        arcade: {\n          gravity: { y: 200 }\n        }\n      },\n      input: {\n        activePointers: 5 // Set the number of allowed active pointers\n      },\n      scene: [\n        MainMenu,\n        Settings,\n        GamemodeSolo,\n        GamemodeTwoPlayer,\n        GamemodeRace,\n        GamemodeChase,\n        GamemodeEscape,\n        EndScreen\n      ]\n    };\n\n    new Phaser.Game(config);\n  }\n\n  /**\n   * Returns the smaller of window.innerWidth and window.innerHeight\n   */\n  _getDimensions() {\n    let width = window.innerWidth;\n    let height = window.innerHeight;\n    if (width < height) {\n      return width;\n    } else {\n      return height;\n    }\n  }\n\n  render() {\n    return <div id=\"phaser-parent\" />;\n  }\n}\n","import React, { Component } from 'react';\nimport Game from './Phaser/src/Game';\nimport './App.css';\n\nclass App extends Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <Game />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","const BLACK = '#000000';\nconst GOLD = '#f9a602';\nconst WHITE = '#ffffff';\nconst GRAY = '#cccccc';\nconst BLUE = '#0000ff';\nconst GREEN = '#00ff00';\n\n// '0x' notation - hexadecimal\nconst BLACK_0x = '0x000000';\nconst GOLD_0x = '0xf9a602';\nconst WHITE_0x = '0xffffff';\nconst GRAY_0x = '0xcccccc';\nconst BLUE_0x = '0x0000ff';\nconst GREEN_0x = '0x00ff00';\n\nmodule.exports = {\n  BLACK,\n  BLACK_0x,\n  GOLD,\n  GOLD_0x,\n  GRAY,\n  GRAY_0x,\n  WHITE,\n  WHITE_0x,\n  BLUE,\n  BLUE_0x,\n  GREEN,\n  GREEN_0x\n};\n","/**\n * https://stackoverflow.com/a/2450976\n */\nfunction shuffle(array) {\n  var currentIndex = array.length,\n    temporaryValue,\n    randomIndex;\n\n  // While there remain elements to shuffle...\n  while (0 !== currentIndex) {\n    // Pick a remaining element...\n    randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex -= 1;\n\n    // And swap it with the current element.\n    temporaryValue = array[currentIndex];\n    array[currentIndex] = array[randomIndex];\n    array[randomIndex] = temporaryValue;\n  }\n\n  return array;\n}\n\nmodule.exports = {\n  shuffle\n};\n"],"sourceRoot":""}